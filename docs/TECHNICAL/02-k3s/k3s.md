# 6. K3s：轻量级 Kubernetes 架构与实践

## 目录

- [目录](#目录)
- [6.1 文档定位](#61-文档定位)
- [6.2 定位与优势](#62-定位与优势)
  - [6.2.1 为什么需要 K3s？](#621-为什么需要-k3s)
  - [6.2.2 K3s vs Kubernetes](#622-k3s-vs-kubernetes)
  - [6.2.3 定位论证](#623-定位论证)
- [6.3 架构设计](#63-架构设计)
  - [6.3.1 单二进制架构](#631-单二进制架构)
  - [6.3.2 组件对比](#632-组件对比)
  - [6.3.3 架构设计论证](#633-架构设计论证)
- [6.4 裁剪策略](#64-裁剪策略)
  - [6.4.1 裁剪清单](#641-裁剪清单)
  - [6.4.2 裁剪策略论证](#642-裁剪策略论证)
- [6.5 存储后端选择](#65-存储后端选择)
  - [6.5.1 三种存储模式](#651-三种存储模式)
  - [6.5.2 sqlite vs etcd](#652-sqlite-vs-etcd)
  - [6.5.3 边缘场景存储决策](#653-边缘场景存储决策)
  - [6.5.4 存储场景与决策](#654-存储场景与决策)
- [6.6 内置组件](#66-内置组件)
  - [6.6.1 containerd](#661-containerd)
  - [6.6.2 flannel](#662-flannel)
  - [6.6.3 traefik](#663-traefik)
  - [6.6.4 metrics-server](#664-metrics-server)
- [6.7 高可用架构](#67-高可用架构)
  - [6.7.1 三种 HA 路径](#671-三种-ha-路径)
  - [6.7.2 HA 配置示例](#672-ha-配置示例)
  - [6.7.3 HA 场景与决策](#673-ha-场景与决策)
- [6.8 性能优化](#68-性能优化)
  - [6.8.1 K3s 性能论证](#681-k3s-性能论证)
  - [6.8.2 性能基线](#682-性能基线)
  - [6.8.3 性能模型形式化](#683-性能模型形式化)
- [6.9 安装与配置](#69-安装与配置)
  - [6.9.1 单节点安装](#691-单节点安装)
  - [6.9.2 多节点安装](#692-多节点安装)
  - [6.9.3 配置文件位置](#693-配置文件位置)
- [6.10 边缘场景实践](#610-边缘场景实践)
  - [6.10.1 ARM 设备部署](#6101-arm-设备部署)
  - [6.10.2 离线部署](#6102-离线部署)
  - [6.10.3 资源限制配置](#6103-资源限制配置)
- [6.11 技术场景分析](#611-技术场景分析)
  - [6.11.1 边缘计算场景](#6111-边缘计算场景)
  - [6.11.2 IoT 场景](#6112-iot-场景)
  - [6.11.3 ARM 设备场景](#6113-arm-设备场景)
- [6.12 故障排查](#612-故障排查)
  - [6.12.1 常见问题](#6121-常见问题)
  - [6.12.2 日志位置](#6122-日志位置)
- [6.13 决策依据与思路](#613-决策依据与思路)
  - [6.13.1 何时选择 K3s？](#6131-何时选择-k3s)
  - [6.13.2 存储后端选择决策树](#6132-存储后端选择决策树)
  - [6.13.3 HA 路径选择决策树](#6133-ha-路径选择决策树)
- [6.14 形式化总结](#614-形式化总结)
  - [6.14.1 K3s 架构模型形式化](#6141-k3s-架构模型形式化)
  - [6.14.2 裁剪模型形式化](#6142-裁剪模型形式化)
  - [6.14.3 性能模型形式化](#6143-性能模型形式化)
  - [6.14.4 存储选择模型形式化](#6144-存储选择模型形式化)
- [6.15 参考](#615-参考)

---

## 6.1 文档定位

本文档深入解析 K3s 的架构设计、裁剪策略和边缘场景最佳实践，以及不同技术场景下的
决策依据和决策思路。

**当前版本（2025）**：

- **K3s 版本**：1.30.4+k3s1（2024-12 发布，2025 年稳定版）
- **关键特性**：内置 WasmEdge 驱动，`--wasm` flag 即开即用
- **生产验证**：ARM64 边缘盒子单节点 3000 Pod 实测稳定

**文档结构**：

- **架构设计**：K3s 单二进制架构和组件设计
- **裁剪策略**：从 K8s 到 K3s 的裁剪方案和论证
- **存储后端**：sqlite/etcd/外部数据库的选择与决策
- **边缘实践**：ARM 设备、离线部署、资源限制
- **技术场景**：边缘计算、IoT、ARM 设备
- **决策分析**：架构选择、存储选择、HA 路径选择

## 6.2 定位与优势

### 6.2.1 为什么需要 K3s？

```mermaid
graph LR
    A[Kubernetes] -->|太重| B[边缘场景需求]
    B --> C[K3s]
    C --> D[轻量]
    C --> E[单二进制]
    C --> F[ARM 支持]

    style A fill:#ffe6e6
    style C fill:#e6ffe6
```

**问题域分析**：

1. **Kubernetes 太重**：控制平面内存占用 ~1GB，不适合资源受限环境
2. **边缘场景需求**：边缘节点资源有限，需要轻量级 Kubernetes
3. **部署复杂**：K8s 需要独立安装 etcd、CNI、Ingress 等组件

**核心思想论证**：

- **轻量化**：裁剪不需要的组件，减小资源占用
- **单二进制**：所有组件打包到单一二进制，简化部署
- **内置组件**：内置 containerd、flannel、traefik，零配置

### 6.2.2 K3s vs Kubernetes

| 维度           | Kubernetes       | K3s                   |
| -------------- | ---------------- | --------------------- |
| **二进制大小** | ~1 GB（多组件）  | ~60 MB（单二进制）    |
| **内存占用**   | ~512 MB 控制平面 | ~250 MB 控制平面      |
| **存储后端**   | 外部 etcd        | sqlite（默认）或 etcd |
| **网络插件**   | 需手动安装       | 内置 flannel          |
| **负载均衡器** | 需手动安装       | 内置 traefik          |
| **适用场景**   | 大规模生产集群   | 边缘、IoT、ARM 设备   |

**对比分析**：

- **二进制大小**：K3s 单二进制 ~60MB，K8s 多组件 ~1GB，减小 94%
- **内存占用**：K3s 控制平面 ~250MB，K8s ~512MB，减小 50%
- **部署复杂度**：K3s 单二进制，K8s 需要多组件安装

### 6.2.3 定位论证

**为什么边缘场景需要 K3s？**

**决策依据**：

- ✅ 资源受限：边缘节点内存有限（< 4GB）
- ✅ 网络不稳定：边缘节点经常掉线
- ✅ 部署简单：需要快速部署和升级

**决策思路**：

```yaml
边缘场景需求:
  资源限制: < 4GB 内存
  网络限制: 不稳定网络
  部署需求: 快速部署
  解决方案: K3s（轻量、单二进制、内置组件）
```

**为什么单二进制架构？**

**决策依据**：

- ✅ 部署简化：单文件安装，无需多组件安装
- ✅ 升级简单：替换二进制即可升级
- ✅ 离线部署：单文件易于离线部署

**决策思路**：

```yaml
单二进制架构:
  优势:
    - 安装简单（curl | sh）
    - 升级简单（替换二进制）
    - 离线部署（单文件）
  权衡:
    - 二进制体积增大
    - 升级需要替换整个二进制
```

## 6.3 架构设计

### 6.3.1 单二进制架构

```mermaid
graph TB
    A[k3s 二进制] --> B[静态链接组件]
    B --> C[containerd]
    B --> D[flannel]
    B --> E[traefik]
    B --> F[sqlite]
    B --> G[kubelet]
    B --> H[kube-proxy]

    I[manifest 目录] --> A
    A --> J[启动时加载<br/>static pod]

    style A fill:#e1f5ff
    style J fill:#fff4e1
```

**架构设计分析**：

1. **单二进制**：所有组件静态链接到 k3s 二进制
2. **嵌入式 manifest**：组件配置内嵌在二进制中
3. **启动时加载**：根据 manifest 目录顺序启动 static pod

### 6.3.2 组件对比

| 组件                         | Kubernetes  | K3s              |
| ---------------------------- | ----------- | ---------------- |
| **kube-api-server**          | ✅ 独立进程 | ✅ 内置          |
| **etcd**                     | ✅ 外部集群 | ✅ sqlite 或外部 |
| **kube-controller-manager**  | ✅ 独立进程 | ✅ 内置          |
| **kube-scheduler**           | ✅ 独立进程 | ✅ 内置          |
| **cloud-controller-manager** | ✅ 独立进程 | ❌ 裁剪          |
| **kubelet**                  | ✅ 节点组件 | ✅ 内置          |
| **kube-proxy**               | ✅ 节点组件 | ✅ 内置          |
| **containerd**               | 外部安装    | ✅ 内置          |
| **CNI 插件**                 | 外部安装    | ✅ 内置 flannel  |
| **Ingress 控制器**           | 外部安装    | ✅ 内置 traefik  |

### 6.3.3 架构设计论证

**为什么采用单二进制架构？**

**决策依据**：

- ✅ 部署简化：单文件安装，无需多组件安装 [^k3s-architecture]
- ✅ 升级简单：替换二进制即可升级
- ✅ 离线部署：单文件易于离线部署

**决策思路**：

```yaml
单二进制架构设计:
  方式: 静态链接所有组件
  优势:
    - 安装简单（curl | sh）
    - 升级简单（替换二进制）
    - 离线部署（单文件）
  权衡:
    - 二进制体积增大（~60MB）
    - 升级需要替换整个二进制
```

**为什么内置组件？**

**决策依据**：

- ✅ 零配置：内置组件自动配置，无需手动安装
- ✅ 资源优化：内置组件共享进程，减少资源占用
- ✅ 简化运维：无需管理多个组件

**决策思路**：

```yaml
内置组件策略:
  组件:
    - containerd: 容器运行时
    - flannel: CNI 网络插件
    - traefik: Ingress 控制器
    - metrics-server: 指标收集
  优势: 零配置、资源优化、简化运维
  权衡: 组件版本固定，升级需要替换二进制
```

## 6.4 裁剪策略

### 6.4.1 裁剪清单

```mermaid
graph TD
    A[K8s 完整功能] --> B[裁剪 Alpha API]
    A --> C[裁剪云控制器]
    A --> D[裁剪 in-tree 存储驱动]
    A --> E[简化存储后端]

    B --> F[K3s 精简版]
    C --> F
    D --> F
    E --> F

    style A fill:#ffe6e6
    style F fill:#e6ffe6
```

| 裁剪项                       | 原因                     | 影响            |
| ---------------------------- | ------------------------ | --------------- |
| **Alpha API**                | 边缘场景不需要实验性功能 | 减少 API 复杂度 |
| **cloud-controller-manager** | 边缘无云环境             | 减小二进制体积  |
| **in-tree 存储驱动**         | 统一使用 CSI             | 简化维护        |
| **etcd（可选）**             | sqlite 满足边缘需求      | 减小资源占用    |

### 6.4.2 裁剪策略论证

**为什么裁剪 Alpha API？**

**决策依据**：

- ✅ 边缘场景不需要实验性功能
- ✅ 减少 API 复杂度
- ✅ 减小二进制体积

**决策思路**：

```yaml
Alpha API 裁剪:
  原因: 边缘场景不需要实验性功能
  影响: 减少 API 复杂度，减小二进制体积
  权衡: 无法使用 Alpha API 功能
```

**为什么裁剪 cloud-controller-manager？**

**决策依据**：

- ✅ 边缘场景无云环境
- ✅ 云控制器功能不需要
- ✅ 减小二进制体积

**决策思路**：

```yaml
cloud-controller-manager 裁剪:
  原因: 边缘场景无云环境
  影响: 减小二进制体积，减少资源占用
  权衡: 无法使用云控制器功能
```

**为什么裁剪 in-tree 存储驱动？**

**决策依据**：

- ✅ 统一使用 CSI
- ✅ 简化维护
- ✅ 减小二进制体积

**决策思路**：

```yaml
in-tree 存储驱动裁剪:
  原因: 统一使用 CSI
  影响: 简化维护，减小二进制体积
  权衡: 必须使用 CSI 存储驱动
```

## 6.5 存储后端选择

### 6.5.1 三种存储模式

```mermaid
graph TB
    A[K3s 存储后端] --> B[嵌入式 etcd]
    A --> C[外部 etcd]
    A --> D[外部数据库<br/>MySQL/PostgreSQL]

    B --> E[单节点/小规模]
    C --> F[中等规模<br/>3-5 节点]
    D --> G[大规模<br/>已有数据库]

    style B fill:#e1f5ff
    style D fill:#fff4e1
```

**存储模式分析**：

1. **嵌入式 etcd**：单节点或小规模集群（< 5 节点）
2. **外部 etcd**：中等规模集群（3-10 节点）
3. **外部数据库**：大规模集群或已有数据库

### 6.5.2 sqlite vs etcd

| 维度           | sqlite            | etcd              |
| -------------- | ----------------- | ----------------- |
| **安装复杂度** | ✅ 零配置         | ❌ 需独立集群     |
| **资源占用**   | ✅ 极低（单文件） | ❌ 需要 3 节点    |
| **网络依赖**   | ✅ 无网络延迟     | ❌ 网络往返 2ms   |
| **数据一致性** | ✅ 最终一致       | ✅ 强一致（Raft） |
| **高可用**     | ❌ 单点           | ✅ 分布式         |
| **适用场景**   | 边缘、单节点      | 生产集群          |

**对比分析**：

- **安装复杂度**：sqlite 零配置，etcd 需要独立集群
- **资源占用**：sqlite 极低（单文件），etcd 需要 3 节点
- **网络依赖**：sqlite 本地调用，etcd 网络往返 2ms
- **数据一致性**：sqlite 最终一致，etcd 强一致（Raft）
- **高可用**：sqlite 单点，etcd 分布式

### 6.5.3 边缘场景存储决策

**问题域分析**：

- 边缘节点常掉电
- 网络不稳定
- 资源受限

**为什么边缘场景选 sqlite？**

**技术论证**：

1. **边缘节点常掉电**：sqlite 单文件复制/备份成本最低
2. **网络分区容忍**：本地继续运行，恢复后同步，接受"最终一致"
3. **Pod 密度低**：边缘节点平均 10 Pod/节点，总对象数 ≈1 万，sqlite 单线程足以
4. **资源受限**：ARM 设备内存有限，sqlite 内存占用极低

```mermaid
graph LR
    A[边缘场景] --> B[掉电频繁]
    A --> C[网络不稳定]
    A --> D[资源受限]

    B --> E[sqlite<br/>单文件备份]
    C --> F[本地运行<br/>最终一致]
    D --> G[极低内存占用]

    style E fill:#e6ffe6
    style F fill:#e6ffe6
    style G fill:#e6ffe6
```

**决策依据**：

- ✅ **边缘节点常掉电**：sqlite 单文件复制/备份成本最低
- ✅ **网络分区容忍**：本地继续运行，恢复后同步，接受"最终一致"
- ✅ **资源受限**：sqlite 内存占用极低，适合 ARM 设备

**决策思路**：

```yaml
边缘场景存储选择:
  场景: 边缘节点（ARM 设备）
  存储: sqlite（默认）
  原因:
    - 单文件备份简单
    - 本地运行，无需网络
    - 资源占用极低
  权衡:
    - 不支持多节点写入
    - 最终一致性，非强一致
  替代方案:
    - 外部 etcd（如果有稳定网络）
    - 外部数据库（如果有现成数据库）
```

### 6.5.4 存储场景与决策

**场景 1：单节点边缘**:

**决策依据**：

- ✅ 单节点部署
- ✅ 资源受限
- ✅ 高可用不重要

**决策思路**：

```yaml
单节点边缘存储:
  选择: sqlite（默认）
  原因: 简单、轻量、零配置
  权衡: 无高可用，单点故障
```

**场景 2：小规模边缘集群（3-5 节点）**:

**决策依据**：

- ✅ 需要高可用
- ✅ 资源相对充足
- ✅ 网络稳定

**决策思路**：

```yaml
小规模边缘集群存储:
  选择: 嵌入式 etcd（--cluster-init）
  原因: 高可用、简单、内置
  权衡: 资源占用增加
```

**场景 3：大规模边缘集群（> 10 节点）**:

**决策依据**：

- ✅ 需要高可用
- ✅ 有现成数据库
- ✅ 资源充足

**决策思路**：

```yaml
大规模边缘集群存储:
  选择: 外部 etcd 或外部数据库
  原因: 高可用、可扩展
  权衡: 依赖外部组件
```

**技术场景对比**：

| 场景               | 存储选择     | 决策依据       | 权衡         |
| ------------------ | ------------ | -------------- | ------------ |
| **单节点边缘**     | sqlite       | 简单、轻量     | 无高可用     |
| **小规模边缘集群** | 嵌入式 etcd  | 高可用、简单   | 资源占用增加 |
| **大规模边缘集群** | 外部 etcd/DB | 高可用、可扩展 | 依赖外部组件 |

## 6.6 内置组件

### 6.6.1 containerd

**定位**：容器运行时接口

**技术特点**：

- **版本**：跟随上游 containerd
- **配置**：自动配置，无需手动管理
- **功能**：容器生命周期管理、镜像管理

**containerd 论证**：

- **内置优势**：无需手动安装，自动配置
- **版本统一**：跟随上游版本，保证兼容性
- **资源优化**：共享进程，减少资源占用

### 6.6.2 flannel

**定位**：CNI 网络插件

**技术特点**：

- **模式**：VXLAN（默认）或 host-gw
- **配置**：自动配置 Pod 网络
- **功能**：Pod 网络管理、服务发现

**flannel 论证**：

- **内置优势**：无需手动安装 CNI 插件
- **自动配置**：Pod 网络自动配置
- **简单易用**：VXLAN 模式简单易用

### 6.6.3 traefik

**定位**：Ingress 控制器和负载均衡器

**技术特点**：

- **功能**：自动发现 Service，提供 HTTP/HTTPS 路由
- **配置**：支持注解配置
- **优势**：零配置，自动发现

**traefik 论证**：

- **内置优势**：无需手动安装 Ingress 控制器
- **自动发现**：自动发现 Service，提供路由
- **配置简单**：通过注解配置，简单易用

### 6.6.4 metrics-server

**定位**：资源指标收集

**技术特点**：

- **功能**：提供 CPU/内存指标，支持 HPA
- **配置**：自动部署
- **优势**：零配置，自动部署

**metrics-server 论证**：

- **内置优势**：无需手动安装 metrics-server
- **自动部署**：自动部署，零配置
- **功能完整**：支持 HPA，功能完整

## 6.7 高可用架构

### 6.7.1 三种 HA 路径

```mermaid
graph TD
    A[K3s HA 路径] --> B[嵌入式 etcd]
    A --> C[外部 etcd]
    A --> D[外部数据库]

    B --> E[k3s server<br/>--cluster-init]
    C --> F[k3s server<br/>--server]
    D --> G[k3s server<br/>--datastore-endpoint]

    style B fill:#e1f5ff
    style D fill:#fff4e1
```

**HA 路径分析**：

1. **嵌入式 etcd**：适合小规模集群（3-5 节点），简单易用
2. **外部 etcd**：适合中等规模集群，高可用
3. **外部数据库**：适合大规模集群或已有数据库

### 6.7.2 HA 配置示例

```bash
# 路径 1：嵌入式 etcd（3 节点）
# 节点 1
k3s server --cluster-init

# 节点 2
k3s server --server https://node1:6443 --token <token>

# 节点 3
k3s server --server https://node1:6443 --token <token>

# 路径 2：外部 etcd
k3s server \
  --datastore-endpoint="etcd" \
  --datastore-cafile=/path/to/ca.pem \
  --datastore-certfile=/path/to/etcd.pem \
  --datastore-keyfile=/path/to/etcd-key.pem

# 路径 3：外部数据库
k3s server \
  --datastore-endpoint="mysql://user:pass@tcp(host:3306)/dbname"
```

### 6.7.3 HA 场景与决策

**场景 1：小规模集群（3-5 节点）**:

**决策依据**：

- ✅ 需要高可用
- ✅ 资源相对充足
- ✅ 网络稳定

**决策思路**：

```yaml
小规模集群 HA:
  选择: 嵌入式 etcd（--cluster-init）
  原因: 高可用、简单、内置
  配置: 3 节点，自动选举
  权衡: 资源占用增加
```

**场景 2：中等规模集群（5-10 节点）**:

**决策依据**：

- ✅ 需要高可用
- ✅ 可以独立部署 etcd
- ✅ 资源充足

**决策思路**：

```yaml
中等规模集群 HA:
  选择: 外部 etcd
  原因: 高可用、可扩展、独立管理
  配置: 3 节点 etcd 集群
  权衡: 需要独立部署 etcd
```

**场景 3：大规模集群（> 10 节点）或已有数据库**:

**决策依据**：

- ✅ 需要高可用
- ✅ 有现成数据库
- ✅ 资源充足

**决策思路**：

```yaml
大规模集群 HA:
  选择: 外部数据库（MySQL/PostgreSQL）
  原因: 高可用、可扩展、利用现有数据库
  配置: 现有数据库集群
  权衡: 依赖外部数据库
```

## 6.8 性能优化

### 6.8.1 K3s 性能论证

**为什么 K3s 能支持 1000 节点？**

**技术论证**：

1. **控制器精简**：去掉大量 controller 与 alpha API，list-watch 压力下降 40%
2. **本地存储**：sqlite 本地调用延迟 0.1ms，比 etcd 网络往返 2ms 低一个量级
3. **Pod 密度低**：边缘节点平均 10 Pod/节点，总对象数 ≈1 万，sqlite 单线程足以
4. **网络拓扑**：星型拓扑，跨节点 watch 少
5. **内存优化**：控制器精简后，内存常驻 < 250MB，树莓派 4B（4GB）可承受

```mermaid
graph TD
    A[K3s 性能优化] --> B[裁剪控制器]
    A --> C[本地 sqlite]
    A --> D[低 Pod 密度]
    A --> E[星型网络]

    B --> F[减少 40% 压力]
    C --> G[延迟 0.1ms]
    D --> H[对象数 ≈1 万]
    E --> I[减少跨节点 watch]

    style F fill:#e6ffe6
    style G fill:#e6ffe6
```

**性能模型论证**：

- **控制器精简**：list-watch 压力下降 40%
- **本地存储**：sqlite 延迟 0.1ms，比 etcd 2ms 低 20 倍
- **Pod 密度**：边缘节点平均 10 Pod/节点，总对象数 ≈1 万
- **网络拓扑**：星型拓扑，跨节点 watch 少
- **内存优化**：内存常驻 < 250MB，树莓派 4B 可承受

### 6.8.2 性能基线

| 指标             | 数值      | 说明             |
| ---------------- | --------- | ---------------- |
| **控制平面内存** | < 250 MB  | 树莓派 4B 可承受 |
| **启动时间**     | < 10s     | 单节点           |
| **支持节点数**   | 1000 节点 | 边缘场景         |
| **sqlite 延迟**  | 0.1ms     | 本地调用         |

**性能基线论证**：

- **控制平面内存**：< 250MB，树莓派 4B（4GB）可承受 [^k3s-memory]
- **启动时间**：< 10s，单二进制启动快
- **支持节点数**：1000 节点，边缘场景足够
- **sqlite 延迟**：0.1ms，本地调用延迟低

### 6.8.3 性能模型形式化

**K3s 性能模型**：
$$P_{K3}(N, P) = f(\text{controller\_count}, \text{storage\_latency}, \text{pod\_density}, \text{network\_topology})$$

其中：

- $N$ = 节点数
- $P$ = Pod 数
- $\text{controller\_count}$ = 控制器数量（减少 40%）
- $\text{storage\_latency}$ = 存储延迟（sqlite 0.1ms）
- $\text{pod\_density}$ = Pod 密度（边缘场景 10 Pod/节点）
- $\text{network\_topology}$ = 网络拓扑（星型）

**优化目标**：
$$\max_{K3} P_{K3}(N, P) = \max_{K3} f(\text{controller\_count} \downarrow, \text{storage\_latency} \downarrow, \text{pod\_density}, \text{network\_topology})$$

## 6.9 安装与配置

### 6.9.1 单节点安装

```bash
# 快速安装
curl -sfL https://get.k3s.io | sh -

# 带 WasmEdge 支持（2025）
curl -sfL https://get.k3s.io | \
  INSTALL_K3S_VERSION=v1.30.4+k3s1 \
  sh -s - --wasm --write-kubeconfig-mode 644
```

**安装论证**：

- **安装简单**：单命令安装，无需多步骤
- **WasmEdge 支持**：通过 `--wasm` 参数启用 WasmEdge 支持

### 6.9.2 多节点安装

```bash
# Server 节点
curl -sfL https://get.k3s.io | K3S_TOKEN=xxx sh -s - server

# Agent 节点
curl -sfL https://get.k3s.io | K3S_TOKEN=xxx \
  K3S_URL=https://server-ip:6443 sh -s - agent
```

**多节点安装论证**：

- **Server 节点**：运行控制平面
- **Agent 节点**：运行工作负载
- **Token 认证**：通过 token 认证节点加入

### 6.9.3 配置文件位置

| 类型           | 路径                                    | 说明            |
| -------------- | --------------------------------------- | --------------- |
| **kubeconfig** | `/etc/rancher/k3s/k3s.yaml`             | 集群配置文件    |
| **数据目录**   | `/var/lib/rancher/k3s`                  | 集群数据        |
| **manifest**   | `/var/lib/rancher/k3s/server/manifests` | Static pod 清单 |

## 6.10 边缘场景实践

### 6.10.1 ARM 设备部署

**场景描述**：ARM 设备（如树莓派）资源受限

**架构挑战**：

1. **资源受限**：内存和 CPU 有限
2. **存储受限**：存储空间有限
3. **网络不稳定**：网络经常掉线

**架构决策**：

```yaml
ARM 设备部署:
  安装: curl | sh（单命令）
  存储: sqlite（默认，单文件）
  网络: flannel（内置，自动配置）
  资源限制: < 250MB 内存
  优势: 简单、轻量、零配置
```

**决策依据**：

- ✅ 资源受限：K3s 内存占用 < 250MB，适合 ARM 设备
- ✅ 存储受限：sqlite 单文件，存储占用小
- ✅ 网络不稳定：sqlite 本地存储，不依赖网络

### 6.10.2 离线部署

**场景描述**：边缘节点无法访问外网

**架构挑战**：

1. **无法下载**：无法从互联网下载镜像和二进制
2. **需要离线安装**：需要在有网络的机器上准备离线包
3. **传输困难**：需要传输离线包到目标机器

**架构决策**：

```yaml
离线部署:
  步骤:
    1. 有网络机器下载离线包（k3s-airgap-images.tar + k3s 二进制） 2.
    传输到目标机器（scp/usb） 3. 离线安装（INSTALL_K3S_SKIP_DOWNLOAD=true）
  优势: 支持离线环境部署
  权衡: 需要准备离线包
```

**决策依据**：

- ✅ 离线环境：支持离线部署，无需互联网
- ✅ 离线包准备：在有网络机器上准备离线包
- ✅ 传输方式：通过 scp/usb 传输离线包

### 6.10.3 资源限制配置

**场景描述**：边缘节点资源有限，需要限制资源使用

**架构挑战**：

1. **资源有限**：内存和 CPU 有限
2. **需要限制**：需要限制 Pod 资源使用
3. **优先级管理**：需要优先级管理

**架构决策**：

```yaml
资源限制配置:
  Node Taints: 限制节点使用
  ResourceQuota: 限制命名空间资源
  LimitRange: 限制 Pod 资源
  优势: 精确控制资源使用
  权衡: 需要配置 ResourceQuota 和 LimitRange
```

## 6.11 技术场景分析

### 6.11.1 边缘计算场景

**场景描述**：边缘计算节点，资源受限，网络不稳定

**架构挑战**：

1. **资源受限**：内存和 CPU 有限
2. **网络不稳定**：经常掉线
3. **存储受限**：存储空间有限

**架构决策**：

```yaml
边缘计算场景:
  选择: K3s
  存储: sqlite（默认）
  网络: flannel（内置）
  资源: < 250MB 内存
  优势: 轻量、简单、离线能力
  权衡: 规模受限（1000 节点）
```

**决策依据**：

- ✅ 资源受限：K3s 内存占用 < 250MB，适合边缘节点
- ✅ 网络不稳定：sqlite 本地存储，不依赖网络
- ✅ 存储受限：sqlite 单文件，存储占用小

### 6.11.2 IoT 场景

**场景描述**：IoT 设备，ARM 架构，资源极度受限

**架构挑战**：

1. **资源极度受限**：内存 < 1GB
2. **ARM 架构**：需要 ARM 版本
3. **离线能力**：需要离线部署

**架构决策**：

```yaml
IoT 场景:
  选择: K3s（ARM 版本）
  存储: sqlite（默认）
  网络: flannel（内置）
  资源: < 250MB 内存
  优势: ARM 支持、轻量、离线能力
  权衡: 功能受限（Alpha API 裁剪）
```

**决策依据**：

- ✅ ARM 架构：K3s 支持 ARM64/ARMv7，适合 IoT 设备
- ✅ 资源极度受限：K3s 内存占用 < 250MB，适合 IoT 设备
- ✅ 离线能力：支持离线部署，适合 IoT 环境

### 6.11.3 ARM 设备场景

**场景描述**：ARM 设备（如树莓派），资源受限，需要容器编排

**架构挑战**：

1. **ARM 架构**：需要 ARM 版本
2. **资源受限**：内存和 CPU 有限
3. **网络不稳定**：网络经常掉线

**架构决策**：

```yaml
ARM 设备场景:
  选择: K3s（ARM 版本）
  存储: sqlite（默认）
  网络: flannel（内置）
  资源: < 250MB 内存
  优势: ARM 支持、轻量、简单
  权衡: 功能受限（Alpha API 裁剪）
```

**决策依据**：

- ✅ ARM 架构：K3s 支持 ARM64/ARMv7
- ✅ 资源受限：K3s 内存占用 < 250MB
- ✅ 网络不稳定：sqlite 本地存储，不依赖网络

## 6.12 故障排查

### 6.12.1 常见问题

| 问题             | 原因                 | 解决方案            |
| ---------------- | -------------------- | ------------------- |
| **节点无法加入** | Token 错误或网络不通 | 检查 token 和防火墙 |
| **Pod 无法启动** | 资源不足             | 检查内存和 CPU      |
| **存储问题**     | sqlite 文件损坏      | 备份并恢复          |
| **网络问题**     | flannel 配置错误     | 检查 CNI 配置       |

**故障排查论证**：

- **节点无法加入**：Token 错误或网络不通，需要检查 token 和防火墙
- **Pod 无法启动**：资源不足，需要检查内存和 CPU
- **存储问题**：sqlite 文件损坏，需要备份并恢复
- **网络问题**：flannel 配置错误，需要检查 CNI 配置

### 6.12.2 日志位置

```bash
# K3s 日志
journalctl -u k3s -f

# containerd 日志
journalctl -u containerd -f

# kubelet 日志
/var/lib/rancher/k3s/agent/containerd/containerd.log
```

## 6.13 决策依据与思路

### 6.13.1 何时选择 K3s？

**决策依据**：

- ✅ 边缘场景（资源受限）
- ✅ IoT 设备（ARM 架构）
- ✅ 节点数 < 1000
- ✅ 不需要 Alpha API

**决策思路**：

```yaml
选择 K3s 的条件:
  if 边缘场景 or IoT 设备 or ARM 设备: 选择 K3s
  elif 节点数 < 1000 and 不需要 Alpha API: 选择 K3s
  elif 资源受限 or 网络不稳定: 选择 K3s
  else: 选择 Kubernetes
```

### 6.13.2 存储后端选择决策树

```yaml
存储后端选择:
  if 单节点边缘: 选择 sqlite（默认）
  elif 小规模集群（3-5 节点）: 选择 嵌入式 etcd（--cluster-init）
  elif 中等规模集群（5-10 节点）: 选择 外部 etcd
  elif 大规模集群（> 10 节点）or 已有数据库: 选择 外部数据库
  else: 选择 sqlite（默认）
```

### 6.13.3 HA 路径选择决策树

```yaml
HA 路径选择:
  if 小规模集群（3-5 节点）: 选择 嵌入式 etcd（--cluster-init）
  elif 中等规模集群（5-10 节点）: 选择 外部 etcd
  elif 大规模集群（> 10 节点）or 已有数据库: 选择 外部数据库
  else: 选择 sqlite（默认，无 HA）
```

## 6.14 形式化总结

### 6.14.1 K3s 架构模型形式化

设 K3s 架构为 $K_3 = \{B, C, S, N\}$，其中：

- $B$ = 单二进制（Single Binary）
- $C$ = 嵌入式组件（Embedded Components）
- $S$ = 存储后端（Storage Backend）
- $N$ = 网络插件（Network Plugin）

**K3s 架构**：
$$K_3 = \{k3s\_binary, \{containerd, flannel, traefik\}, \{sqlite|etcd|DB\}, flannel\}$$

### 6.14.2 裁剪模型形式化

**裁剪函数**：
$$K_3 = \text{Trim}(K, \{\text{Alpha API}, \text{cloud-controller}, \text{in-tree-storage}\})$$

其中 $K$ 是完整的 Kubernetes 功能集，通过裁剪得到 $K_3$。

**裁剪效果**：

- 二进制体积：从 ~1GB 减小到 ~60MB（减小 94%）
- 内存占用：从 ~512MB 减小到 ~250MB（减小 50%）
- API 复杂度：减少 Alpha API，降低复杂度

### 6.14.3 性能模型形式化

**K3s 性能模型**：
$$P_{K3}(N, P) = \alpha \cdot \text{controller\_count} + \beta \cdot \text{storage\_latency} + \gamma \cdot \text{pod\_density}$$

其中：

- $N$ = 节点数
- $P$ = Pod 数
- $\alpha$ = 控制器权重（减少 40%）
- $\beta$ = 存储延迟权重（sqlite 0.1ms）
- $\gamma$ = Pod 密度权重（边缘场景 10 Pod/节点）

**优化目标**：
$$\min_{K3} P_{K3}(N, P) = \min_{K3} (\alpha \cdot \text{controller\_count} \downarrow + \beta \cdot \text{storage\_latency} \downarrow + \gamma \cdot \text{pod\_density})$$

### 6.14.4 存储选择模型形式化

**存储选择函数**：

$$
S(N, R, E) = \begin{cases}
\text{sqlite} & \text{if } N = 1 \land R < 4\text{GB} \\
\text{embedded etcd} & \text{if } 3 \leq N \leq 5 \land R \geq 4\text{GB} \\
\text{external etcd} & \text{if } 5 < N \leq 10 \\
\text{external DB} & \text{if } N > 10 \lor E = \text{true}
\end{cases}
$$

其中：

- $N$ = 节点数
- $R$ = 资源（内存）
- $E$ = 已有数据库（true/false）

## 6.15 参考

- [37. 矩阵视角](../COGNITIVE/09-matrix-perspective/README.md) - K3s 技术链矩阵
  分析（边缘场景优化）

**外部参考**：

[^k3s-architecture]: [K3s Architecture](https://docs.k3s.io/architecture)
[^k3s-memory]:
    [K3s Resource Requirements](https://docs.k3s.io/installation/requirements)

> 完整参考列表见 [REFERENCES.md](../REFERENCES.md)
