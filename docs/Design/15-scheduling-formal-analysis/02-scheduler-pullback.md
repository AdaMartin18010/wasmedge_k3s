# äºŒã€è°ƒåº¦å†³ç­–ä½œä¸ºæ‹‰å›

> **æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0 **æœ€åæ›´æ–°**ï¼š2025-11-10 **ç»´æŠ¤è€…**ï¼šé¡¹ç›®å›¢é˜Ÿ

---

## ğŸ“‘ ç›®å½•

- [ğŸ“‘ ç›®å½•](#-ç›®å½•)
- [æ¦‚è¿°](#æ¦‚è¿°)
- [ä¸€ã€è°ƒåº¦æ‹‰å›å›¾å®šä¹‰](#ä¸€è°ƒåº¦æ‹‰å›å›¾å®šä¹‰)
  - [1.1 æ‹‰å›å›¾æ„é€ ](#11-æ‹‰å›å›¾æ„é€ )
  - [1.2 æ‹‰å›å¯¹è±¡](#12-æ‹‰å›å¯¹è±¡)
  - [1.3 æ‹‰å›å”¯ä¸€æ€§](#13-æ‹‰å›å”¯ä¸€æ€§)
- [äºŒã€èµ„æºè¯·æ±‚ä¸å¯ç”¨å®¹é‡çš„æ‹‰å›](#äºŒèµ„æºè¯·æ±‚ä¸å¯ç”¨å®¹é‡çš„æ‹‰å›)
  - [2.1 èµ„æºè¯·æ±‚å‡½å­](#21-èµ„æºè¯·æ±‚å‡½å­)
  - [2.2 å¯ç”¨å®¹é‡å‡½å­](#22-å¯ç”¨å®¹é‡å‡½å­)
  - [2.3 æ‹‰å›æ„é€ ](#23-æ‹‰å›æ„é€ )
- [ä¸‰ã€æˆæœ¬å‡½æ•°çš„åº¦é‡å¼ é‡](#ä¸‰æˆæœ¬å‡½æ•°çš„åº¦é‡å¼ é‡)
  - [3.1 æˆæœ¬å‡½æ•°å®šä¹‰](#31-æˆæœ¬å‡½æ•°å®šä¹‰)
  - [3.2 æˆæœ¬å‡½æ•°çš„åº¦é‡å¼ é‡](#32-æˆæœ¬å‡½æ•°çš„åº¦é‡å¼ é‡)
  - [3.3 æˆæœ¬å‡½æ•°ä¼˜åŒ–](#33-æˆæœ¬å‡½æ•°ä¼˜åŒ–)
- [å››ã€è°ƒåº¦å†³ç­–çš„å½¢å¼åŒ–éªŒè¯](#å››è°ƒåº¦å†³ç­–çš„å½¢å¼åŒ–éªŒè¯)
  - [4.1 è°ƒåº¦å†³ç­–å­˜åœ¨æ€§éªŒè¯](#41-è°ƒåº¦å†³ç­–å­˜åœ¨æ€§éªŒè¯)
  - [4.2 è°ƒåº¦å†³ç­–å”¯ä¸€æ€§éªŒè¯](#42-è°ƒåº¦å†³ç­–å”¯ä¸€æ€§éªŒè¯)
- [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## æ¦‚è¿°

æœ¬æ–‡æ¡£ä»**èŒƒç•´è®º**çš„è§†è§’å½¢å¼åŒ–åˆ†æè°ƒåº¦å†³ç­–ï¼Œå°†è°ƒåº¦å†³ç­–æŠ½è±¡ä¸ºæ‹‰å›ï¼ˆPullbackï¼‰æ„é€ 
ï¼Œé€šè¿‡æ‹‰å›å›¾æè¿°èµ„æºè¯·æ±‚ä¸å¯ç”¨å®¹é‡çš„åŒ¹é…è¿‡ç¨‹ï¼Œå»ºç«‹è°ƒåº¦å†³ç­–çš„ä¸¥æ ¼æ•°å­¦æ¨¡å‹ã€‚

**ä¸ºä»€ä¹ˆä½¿ç”¨æ‹‰å›æ„é€ åˆ†æè°ƒåº¦å†³ç­–ï¼Ÿ**

æ‹‰å›æ„é€ æä¾›äº†ç»Ÿä¸€çš„æ•°å­¦æ¡†æ¶æ¥æè¿°è°ƒåº¦å†³ç­–çš„ç»“æ„å’Œè¡Œä¸ºï¼š

1. **ç»Ÿä¸€æŠ½è±¡**ï¼šé€šè¿‡æ‹‰å›æ„é€ ï¼Œæˆ‘ä»¬å¯ä»¥å°†èµ„æºè¯·æ±‚ä¸å¯ç”¨å®¹é‡çš„åŒ¹é…æŠ½è±¡ä¸ºæ‹‰å›å¯¹è±¡
   ï¼Œå®ç°ç»Ÿä¸€çš„æ•°å­¦æè¿°
2. **ç»“æ„ä¿æŒ**ï¼šé€šè¿‡æ‹‰å›æ„é€ ä¿æŒè°ƒåº¦å†³ç­–çš„ç»“æ„ï¼Œç¡®ä¿è°ƒåº¦å†³ç­–çš„æ­£ç¡®æ€§
3. **å”¯ä¸€æ€§ä¿è¯**ï¼šé€šè¿‡æ‹‰å›æ„é€ çš„å”¯ä¸€æ€§ï¼Œæˆ‘ä»¬å¯ä»¥ä¿è¯è°ƒåº¦å†³ç­–çš„å”¯ä¸€æ€§

**æ‹‰å›æ„é€ åœ¨è°ƒåº¦å†³ç­–åˆ†æä¸­çš„åº”ç”¨**ï¼š

- **æ‹‰å›å›¾ï¼ˆPullback Diagramï¼‰**ï¼šè°ƒåº¦æ‹‰å›å›¾ï¼Œæè¿°èµ„æºè¯·æ±‚ä¸å¯ç”¨å®¹é‡çš„åŒ¹é…
- **æ‹‰å›å¯¹è±¡ï¼ˆPullback Objectï¼‰**ï¼šè°ƒåº¦å†³ç­–ä½œä¸ºæ‹‰å›å¯¹è±¡ï¼Œæè¿°è°ƒåº¦å†³ç­–çš„ç»“æ„
- **æˆæœ¬å‡½æ•°åº¦é‡å¼ é‡ï¼ˆCost Function Metric Tensorï¼‰**ï¼šæˆæœ¬å‡½æ•°çš„åº¦é‡å¼ é‡ï¼Œæè¿°
  è°ƒåº¦æˆæœ¬çš„å¤šç»´åº¦é‡

**æ ¸å¿ƒå†…å®¹**ï¼š

1. **è°ƒåº¦æ‹‰å›å›¾å®šä¹‰**ï¼šPodSpec â†’ ResourceRequestï¼ŒNodeStatus â†’ AvailableCapacity
2. **èµ„æºè¯·æ±‚ä¸å¯ç”¨å®¹é‡çš„æ‹‰å›**ï¼šè°ƒåº¦å†³ç­–ä½œä¸ºæ‹‰å›å¯¹è±¡
3. **æˆæœ¬å‡½æ•°çš„åº¦é‡å¼ é‡**ï¼šè°ƒåº¦æˆæœ¬çš„å¤šç»´åº¦é‡
4. **è°ƒåº¦å†³ç­–çš„å½¢å¼åŒ–éªŒè¯**ï¼šè°ƒåº¦å†³ç­–å­˜åœ¨æ€§ã€å”¯ä¸€æ€§éªŒè¯

---

## ä¸€ã€è°ƒåº¦æ‹‰å›å›¾å®šä¹‰

### 1.1 æ‹‰å›å›¾æ„é€ 

**è°ƒåº¦å†³ç­–ä½œä¸ºæ‹‰å›ï¼ˆPullbackï¼‰**ï¼š

```mermaid
graph TD
    subgraph "è°ƒåº¦æ‹‰å›å›¾"
        A[PodSpec] --> B[ResourceRequest]
        C[NodeStatus] --> D[AvailableCapacity]
        B --> E[SchedulerDecision]
        D --> E
        E --> F[AssignedNode]
    end
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
è°ƒåº¦å†³ç­– = Pullback(ResourceRequest, AvailableCapacity)
å…¶ä¸­ ResourceRequest = PodSpec â†’ Resource
     AvailableCapacity = NodeStatus â†’ Resource
```

**æ‹‰å›å›¾äº¤æ¢æ¡ä»¶**ï¼š

```text
âˆ€podSpec âˆˆ PodSpec, nodeStatus âˆˆ NodeStatus:
ResourceRequest(podSpec) = AvailableCapacity(nodeStatus) â†’
SchedulerDecision(podSpec, nodeStatus) = AssignedNode
```

**ä¸ºä»€ä¹ˆæ‹‰å›å›¾äº¤æ¢æ¡ä»¶é‡è¦ï¼Ÿ**

æ‹‰å›å›¾äº¤æ¢æ¡ä»¶å…è®¸æˆ‘ä»¬æè¿°èµ„æºè¯·æ±‚ä¸å¯ç”¨å®¹é‡çš„åŒ¹é…ï¼Œè¿™å¯¹äºè°ƒåº¦å†³ç­–çš„æ­£ç¡®æ€§è‡³å…³é‡
è¦ã€‚

**æ‹‰å›å›¾äº¤æ¢æ¡ä»¶çš„æ•°å­¦è¯æ˜**ï¼š

è®¾ `PodSpec` ä¸º Pod è§„æ ¼ï¼Œ`NodeStatus` ä¸ºèŠ‚ç‚¹çŠ¶æ€ï¼Œ`ResourceRequest` ä¸ºèµ„æºè¯·æ±‚
å‡½å­ï¼Œ`AvailableCapacity` ä¸ºå¯ç”¨å®¹é‡å‡½å­ã€‚

æ ¹æ®æ‹‰å›å›¾äº¤æ¢æ¡ä»¶çš„å®šä¹‰ï¼Œå¯¹äºä»»æ„ `podSpec âˆˆ PodSpec` å’Œ
`nodeStatus âˆˆ NodeStatus`ï¼Œå¦‚æœ
`ResourceRequest(podSpec) = AvailableCapacity(nodeStatus)`ï¼Œåˆ™
`SchedulerDecision(podSpec, nodeStatus) = AssignedNode`ã€‚

**è¯æ˜**ï¼š

ç”±äºè°ƒåº¦å†³ç­–ä½œä¸ºæ‹‰å›å¯¹è±¡ï¼Œå½“èµ„æºè¯·æ±‚ä¸å¯ç”¨å®¹é‡åŒ¹é…æ—¶ï¼Œè°ƒåº¦å†³ç­–å°† Pod è°ƒåº¦åˆ°åŒ¹é…
çš„èŠ‚ç‚¹ã€‚

å› æ­¤ï¼Œæ‹‰å›å›¾äº¤æ¢æ¡ä»¶æˆç«‹ã€‚

**æ‹‰å›å›¾äº¤æ¢æ¡ä»¶çš„å®é™…åº”ç”¨**ï¼š

æ‹‰å›å›¾äº¤æ¢æ¡ä»¶åœ¨å®é™…åº”ç”¨ä¸­æœ‰ä»¥ä¸‹ç”¨é€”ï¼š

1. **è°ƒåº¦å†³ç­–**ï¼šé€šè¿‡äº¤æ¢æ¡ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥è¿›è¡Œè°ƒåº¦å†³ç­–
2. **èµ„æºåŒ¹é…**ï¼šé€šè¿‡äº¤æ¢æ¡ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥åŒ¹é…èµ„æºè¯·æ±‚ä¸å¯ç”¨å®¹é‡
3. **è°ƒåº¦éªŒè¯**ï¼šé€šè¿‡äº¤æ¢æ¡ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥éªŒè¯è°ƒåº¦å†³ç­–çš„æ­£ç¡®æ€§

### 1.2 æ‹‰å›å¯¹è±¡

**æ‹‰å›å¯¹è±¡** `SchedulerDecision`ï¼š

```haskell
-- æ‹‰å›å¯¹è±¡ç±»å‹
data SchedulerDecision = Decision {
    podSpec :: PodSpec,
    nodeStatus :: NodeStatus,
    resourceRequest :: ResourceRequest,
    availableCapacity :: AvailableCapacity,
    assignedNode :: Node
}

-- æ‹‰å›å¯¹è±¡æ„é€ 
pullback :: PodSpec -> NodeStatus -> SchedulerDecision
pullback podSpec nodeStatus =
    let resourceRequest = extractResourceRequest podSpec
        availableCapacity = extractAvailableCapacity nodeStatus
        assignedNode = findMatchingNode resourceRequest availableCapacity
    in Decision podSpec nodeStatus resourceRequest availableCapacity assignedNode
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
SchedulerDecision = Pullback(ResourceRequest, AvailableCapacity)
å…¶ä¸­ ResourceRequest = PodSpec â†’ Resource
     AvailableCapacity = NodeStatus â†’ Resource
```

### 1.3 æ‹‰å›å”¯ä¸€æ€§

**æ‹‰å›å”¯ä¸€æ€§å®šç†**ï¼š

```text
âˆ€podSpec âˆˆ PodSpec, nodeStatus âˆˆ NodeStatus:
âˆƒ!decision âˆˆ SchedulerDecision,
decision.podSpec = podSpec âˆ§ decision.nodeStatus = nodeStatus
```

**å½¢å¼åŒ–éªŒè¯**ï¼š

```haskell
-- æ‹‰å›å”¯ä¸€æ€§éªŒè¯
verifyPullbackUniqueness :: PodSpec -> NodeStatus -> Bool
verifyPullbackUniqueness podSpec nodeStatus =
    let decisions = findAllDecisions podSpec nodeStatus
    in length decisions == 1
```

---

## äºŒã€èµ„æºè¯·æ±‚ä¸å¯ç”¨å®¹é‡çš„æ‹‰å›

### 2.1 èµ„æºè¯·æ±‚å‡½å­

**èµ„æºè¯·æ±‚å‡½å­** `ResourceRequest: PodSpec â†’ Resource`ï¼š

```haskell
-- èµ„æºè¯·æ±‚å‡½å­ç±»å‹
data ResourceRequestFunctor = ResourceRequest {
    extract :: PodSpec -> ResourceRequest,
    validate :: ResourceRequest -> Bool,
    match :: ResourceRequest -> AvailableCapacity -> Bool
}

-- èµ„æºè¯·æ±‚å‡½å­å®ä¾‹
instance Functor ResourceRequest where
    fmap f (ResourceRequest extract validate match) =
        ResourceRequest (f . extract) validate match
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
ResourceRequest: PodSpec â†’ Resource
ResourceRequest(podSpec) = {cpu, memory, storage, network}
```

**èµ„æºè¯·æ±‚æå–**ï¼š

```haskell
-- èµ„æºè¯·æ±‚æå–
extractResourceRequest :: PodSpec -> ResourceRequest
extractResourceRequest podSpec =
    ResourceRequest {
        cpu = podSpec.cpu.request,
        memory = podSpec.memory.request,
        storage = podSpec.storage.request,
        network = podSpec.network.request
    }
```

### 2.2 å¯ç”¨å®¹é‡å‡½å­

**å¯ç”¨å®¹é‡å‡½å­** `AvailableCapacity: NodeStatus â†’ Resource`ï¼š

```haskell
-- å¯ç”¨å®¹é‡å‡½å­ç±»å‹
data AvailableCapacityFunctor = AvailableCapacity {
    extract :: NodeStatus -> AvailableCapacity,
    validate :: AvailableCapacity -> Bool,
    match :: AvailableCapacity -> ResourceRequest -> Bool
}

-- å¯ç”¨å®¹é‡å‡½å­å®ä¾‹
instance Functor AvailableCapacity where
    fmap f (AvailableCapacity extract validate match) =
        AvailableCapacity (f . extract) validate match
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
AvailableCapacity: NodeStatus â†’ Resource
AvailableCapacity(nodeStatus) = {cpu, memory, storage, network}
```

**å¯ç”¨å®¹é‡æå–**ï¼š

```haskell
-- å¯ç”¨å®¹é‡æå–
extractAvailableCapacity :: NodeStatus -> AvailableCapacity
extractAvailableCapacity nodeStatus =
    AvailableCapacity {
        cpu = nodeStatus.cpu.available,
        memory = nodeStatus.memory.available,
        storage = nodeStatus.storage.available,
        network = nodeStatus.network.available
    }
```

### 2.3 æ‹‰å›æ„é€ 

**æ‹‰å›æ„é€ **ï¼š

```haskell
-- æ‹‰å›æ„é€ 
pullback :: ResourceRequest -> AvailableCapacity -> SchedulerDecision
pullback resourceRequest availableCapacity =
    let matching = matchResource resourceRequest availableCapacity
        assignedNode = findBestNode matching
    in Decision resourceRequest availableCapacity assignedNode
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
Pullback(ResourceRequest, AvailableCapacity) =
  {decision | decision.resourceRequest = ResourceRequest âˆ§
              decision.availableCapacity = AvailableCapacity âˆ§
              decision.resourceRequest â‰¤ decision.availableCapacity}
```

**æ‹‰å›æ„é€ æ¡ä»¶**ï¼š

```text
âˆ€r âˆˆ Resource, request(r) â‰¤ available(r)
```

---

## ä¸‰ã€æˆæœ¬å‡½æ•°çš„åº¦é‡å¼ é‡

### 3.1 æˆæœ¬å‡½æ•°å®šä¹‰

**æˆæœ¬å‡½æ•°** `cost: (PodSpec, Node) â†’ Double`ï¼š

```haskell
-- æˆæœ¬å‡½æ•°ç±»å‹
data CostFunction = Cost {
    cpuFragmentation :: PodSpec -> Node -> Double,
    memoryPressure :: PodSpec -> Node -> Double,
    networkTopology :: PodSpec -> Node -> Double,
    totalCost :: PodSpec -> Node -> Double
}

-- æˆæœ¬å‡½æ•°å®ä¾‹
costFunction = Cost {
    cpuFragmentation = \p n -> calculateCPUFragmentation p n,
    memoryPressure = \p n -> calculateMemoryPressure p n,
    networkTopology = \p n -> calculateNetworkTopology p n,
    totalCost = \p n ->
        wâ‚ * cpuFragmentation p n +
        wâ‚‚ * memoryPressure p n +
        wâ‚ƒ * networkTopology p n
}
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
cost(p, n) = wâ‚Â·cpu_fragmentation + wâ‚‚Â·memory_pressure + wâ‚ƒÂ·network_topology
```

å…¶ä¸­ï¼š

- **wâ‚**ï¼šCPU ç¢ç‰‡åŒ–æƒé‡
- **wâ‚‚**ï¼šå†…å­˜å‹åŠ›æƒé‡
- **wâ‚ƒ**ï¼šç½‘ç»œæ‹“æ‰‘æƒé‡

### 3.2 æˆæœ¬å‡½æ•°çš„åº¦é‡å¼ é‡

**æˆæœ¬å‡½æ•°çš„åº¦é‡å¼ é‡**ï¼š

```haskell
-- æˆæœ¬å‡½æ•°çš„åº¦é‡å¼ é‡ç±»å‹
data CostTensor = Tensor {
    dimensions :: [CostDimension],
    weights :: [Double],
    values :: Map (PodSpec, Node) Double
}

-- æˆæœ¬å‡½æ•°çš„åº¦é‡å¼ é‡å®ä¾‹
costTensor = Tensor {
    dimensions = [CPUFragmentation, MemoryPressure, NetworkTopology],
    weights = [wâ‚, wâ‚‚, wâ‚ƒ],
    values = Map.fromList [(p, n) -> cost(p, n) | p <- podSpecs, n <- nodes]
}
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
T_cost âˆˆ â„^{3Ã—3} ç»´åº¦ï¼š(CPUç¢ç‰‡åŒ–, å†…å­˜å‹åŠ›, ç½‘ç»œæ‹“æ‰‘)
cost(p, n) = Î£_{i=1}^3 w_i Â· T_cost[i](p, n)
```

**æˆæœ¬å‡½æ•°å¯¹æ¯”**ï¼š

| **ç»´åº¦**       | **å®¹å™¨è°ƒåº¦** | **è™šæ‹Ÿæœºè°ƒåº¦** | **æƒé‡** |
| -------------- | ------------ | -------------- | -------- |
| **CPU ç¢ç‰‡åŒ–** | ä½           | ä¸­             | wâ‚ = 0.3 |
| **å†…å­˜å‹åŠ›**   | ä½           | é«˜             | wâ‚‚ = 0.4 |
| **ç½‘ç»œæ‹“æ‰‘**   | ä¸­           | é«˜             | wâ‚ƒ = 0.3 |

### 3.3 æˆæœ¬å‡½æ•°ä¼˜åŒ–

**æˆæœ¬å‡½æ•°ä¼˜åŒ–**ï¼š

```haskell
-- æˆæœ¬å‡½æ•°ä¼˜åŒ–
optimizeCost :: PodSpec -> NodeList -> Node
optimizeCost podSpec nodeList =
    let costs = map (\n -> (n, cost podSpec n)) nodeList
        sorted = sortBy (compare `on` snd) costs
    in fst (head sorted)
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
optimalNode = argmin_{nâˆˆNodeList} cost(podSpec, n)
```

**ä¼˜åŒ–ç®—æ³•**ï¼š

1. **è´ªå¿ƒç®—æ³•**ï¼šé€‰æ‹©æˆæœ¬æœ€ä½çš„èŠ‚ç‚¹
2. **åŠ¨æ€è§„åˆ’**ï¼šè€ƒè™‘æœªæ¥è°ƒåº¦æˆæœ¬
3. **é—ä¼ ç®—æ³•**ï¼šè¿›åŒ–ä¼˜åŒ–è°ƒåº¦ç­–ç•¥

---

## å››ã€è°ƒåº¦å†³ç­–çš„å½¢å¼åŒ–éªŒè¯

### 4.1 è°ƒåº¦å†³ç­–å­˜åœ¨æ€§éªŒè¯

**è°ƒåº¦å†³ç­–å­˜åœ¨æ€§å®šç†**ï¼š

```text
â–¡(âˆ€p âˆˆ PodSpec, N âˆˆ NodeList,
  âˆƒn âˆˆ N, request(p) â‰¤ available(n) â†’
  âˆƒdecision âˆˆ SchedulerDecision, decision.assignedNode = n)
```

**å½¢å¼åŒ–éªŒè¯**ï¼š

```haskell
-- è°ƒåº¦å†³ç­–å­˜åœ¨æ€§éªŒè¯
verifySchedulerDecisionExistence :: PodSpec -> NodeList -> Bool
verifySchedulerDecisionExistence podSpec nodeList =
    let resourceRequest = extractResourceRequest podSpec
        availableCapacities = map extractAvailableCapacity nodeList
        matching = filter (matchResource resourceRequest) availableCapacities
    in not (null matching)
```

**å­˜åœ¨æ€§æ€§è´¨**ï¼š

1. **èµ„æºçº¦æŸæ»¡è¶³**ï¼š`âˆ€p, N, âˆƒn âˆˆ N, request(p) â‰¤ available(n) â†’ âˆƒdecision`
2. **è°ƒåº¦å†³ç­–å¯è¾¾**ï¼š`âˆ€p, N, âˆƒdecision â†’ decision.assignedNode âˆˆ N`
3. **è°ƒåº¦å†³ç­–æœ‰
   æ•ˆ**ï¼š`âˆ€decision, decision.resourceRequest â‰¤ decision.availableCapacity`

### 4.2 è°ƒåº¦å†³ç­–å”¯ä¸€æ€§éªŒè¯

**è°ƒåº¦å†³ç­–å”¯ä¸€æ€§å®šç†**ï¼š

```text
â–¡(âˆ€p âˆˆ PodSpec, N âˆˆ NodeList,
  âˆƒ!n âˆˆ N, cost(p, n) = min_{n'âˆˆN} cost(p, n'))
```

**å½¢å¼åŒ–éªŒè¯**ï¼š

```haskell
-- è°ƒåº¦å†³ç­–å”¯ä¸€æ€§éªŒè¯
verifySchedulerDecisionUniqueness :: PodSpec -> NodeList -> Bool
verifySchedulerDecisionUniqueness podSpec nodeList =
    let costs = map (\n -> (n, cost podSpec n)) nodeList
        minCost = minimum (map snd costs)
        optimalNodes = filter ((== minCost) . snd) costs
    in length optimalNodes == 1
```

**å”¯ä¸€æ€§æ€§è´¨**ï¼š

1. **æˆæœ¬å‡½æ•°ä¸¥æ ¼å•è°ƒ**ï¼š`âˆ€p, nâ‚, nâ‚‚, cost(p, nâ‚) â‰  cost(p, nâ‚‚) â†’ nâ‚ â‰  nâ‚‚`
2. **æœ€ä¼˜èŠ‚ç‚¹å”¯ä¸€**ï¼š`âˆ€p, N, âˆƒ!n âˆˆ N, cost(p, n) = min_{n'âˆˆN} cost(p, n')`
3. **è°ƒåº¦å†³ç­–å”¯ä¸€**ï¼š`âˆ€p, N, âˆƒ!decision, decision.assignedNode = optimalNode`

---

## ç›¸å…³æ–‡æ¡£

- [è°ƒåº¦å™¨çš„æ‹‰å›æ„é€ ](./01-scheduler-category-theory.md) - è°ƒåº¦å™¨èŒƒç•´è®ºæ¨¡å‹
- [è™šæ‹Ÿæœºè°ƒåº¦çš„æ‰©å±•æ‹‰å›](./03-vm-scheduling-extension.md) - VM è°ƒåº¦æ‰©å±•æ‹‰å›
- [NUMA æ‹“æ‰‘å‡½å­](./04-numa-topology-functor.md) - NUMA æ‹“æ‰‘å‡½å­
- [æ ¸å¿ƒåŠŸèƒ½æ¶æ„çŸ©é˜µå¯¹æ¯”](../01-core-architecture/01-architecture-matrix.md) - åŠŸ
  èƒ½åŸŸå¯¹æ¯”çŸ©é˜µ

---

**æœ€åæ›´æ–°**ï¼š2025-11-10 **ç»´æŠ¤è€…**ï¼šé¡¹ç›®å›¢é˜Ÿ
