# å››ã€è´Ÿè½½å‡è¡¡çš„ä»£æ•°ç»“æ„

> **æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0 **æœ€åæ›´æ–°**ï¼š2025-11-10 **ç»´æŠ¤è€…**ï¼šé¡¹ç›®å›¢é˜Ÿ

---

## ğŸ“‘ ç›®å½•

- [å››ã€è´Ÿè½½å‡è¡¡çš„ä»£æ•°ç»“æ„](#å››è´Ÿè½½å‡è¡¡çš„ä»£æ•°ç»“æ„)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
  - [ä¸€ã€æœåŠ¡å‘ç°å¹ºåŠç¾¤](#ä¸€æœåŠ¡å‘ç°å¹ºåŠç¾¤)
    - [1.1 å¹ºåŠç¾¤å®šä¹‰](#11-å¹ºåŠç¾¤å®šä¹‰)
    - [1.2 è´Ÿè½½å‡è¡¡è¿ç®—](#12-è´Ÿè½½å‡è¡¡è¿ç®—)
    - [1.3 å•ä½å…ƒä¸é€†å…ƒ](#13-å•ä½å…ƒä¸é€†å…ƒ)
  - [äºŒã€è´Ÿè½½å‡è¡¡ç®—æ³•](#äºŒè´Ÿè½½å‡è¡¡ç®—æ³•)
    - [2.1 éšæœºé€‰æ‹©ç®—æ³•](#21-éšæœºé€‰æ‹©ç®—æ³•)
    - [2.2 åŠ æƒè½®è¯¢ç®—æ³•](#22-åŠ æƒè½®è¯¢ç®—æ³•)
    - [2.3 æœ€å°‘è¿æ¥ç®—æ³•](#23-æœ€å°‘è¿æ¥ç®—æ³•)
    - [2.4 ä¸€è‡´æ€§å“ˆå¸Œç®—æ³•](#24-ä¸€è‡´æ€§å“ˆå¸Œç®—æ³•)
  - [ä¸‰ã€è´Ÿè½½å‡è¡¡ Monad](#ä¸‰è´Ÿè½½å‡è¡¡-monad)
    - [3.1 Service Monad å®šä¹‰](#31-service-monad-å®šä¹‰)
    - [3.2 å®¹å™¨å®ç°](#32-å®¹å™¨å®ç°)
    - [3.3 è™šæ‹Ÿæœºå®ç°](#33-è™šæ‹Ÿæœºå®ç°)
  - [å››ã€é©¬å°”å¯å¤«é“¾æ¨¡å‹](#å››é©¬å°”å¯å¤«é“¾æ¨¡å‹)
    - [4.1 åç«¯çŠ¶æ€é©¬å°”å¯å¤«é“¾](#41-åç«¯çŠ¶æ€é©¬å°”å¯å¤«é“¾)
    - [4.2 è½¬ç§»æ¦‚ç‡çŸ©é˜µ](#42-è½¬ç§»æ¦‚ç‡çŸ©é˜µ)
    - [4.3 ç¨³æ€åˆ†å¸ƒ](#43-ç¨³æ€åˆ†å¸ƒ)
  - [äº”ã€è´Ÿè½½å‡è¡¡å¤æ‚åº¦åˆ†æ](#äº”è´Ÿè½½å‡è¡¡å¤æ‚åº¦åˆ†æ)
    - [5.1 æ—¶é—´å¤æ‚åº¦](#51-æ—¶é—´å¤æ‚åº¦)
    - [5.2 ç©ºé—´å¤æ‚åº¦](#52-ç©ºé—´å¤æ‚åº¦)
    - [5.3 æ€§èƒ½å¯¹æ¯”](#53-æ€§èƒ½å¯¹æ¯”)
  - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## æ¦‚è¿°

æœ¬æ–‡æ¡£ä»**ä»£æ•°ç»“æ„**çš„è§†è§’åˆ†æè´Ÿè½½å‡è¡¡ç³»ç»Ÿï¼Œå°†æœåŠ¡å‘ç°ã€è´Ÿè½½å‡è¡¡ç®—æ³•ã€åç«¯çŠ¶æ€ç®¡
ç†ç­‰æŠ½è±¡ä¸ºå¹ºåŠç¾¤ã€Monadã€é©¬å°”å¯å¤«é“¾ç­‰æ•°å­¦ç»“æ„ï¼Œå»ºç«‹è´Ÿè½½å‡è¡¡ç³»ç»Ÿçš„ä»£æ•°æ¨¡å‹ã€‚

**ä¸ºä»€ä¹ˆä½¿ç”¨ä»£æ•°ç»“æ„åˆ†æè´Ÿè½½å‡è¡¡ç³»ç»Ÿï¼Ÿ**

ä»£æ•°ç»“æ„æä¾›äº†ç»Ÿä¸€çš„æ•°å­¦æ¡†æ¶æ¥æè¿°è´Ÿè½½å‡è¡¡ç³»ç»Ÿçš„ç»“æ„å’Œè¡Œä¸ºï¼š

1. **ç»“æ„ä¿æŒ**ï¼šå¹ºåŠç¾¤ä¿æŒè´Ÿè½½å‡è¡¡è¿ç®—çš„ç»“æ„ï¼Œç¡®ä¿è´Ÿè½½å‡è¡¡æ“ä½œçš„æ­£ç¡®æ€§
2. **ç»„åˆæ€§**ï¼šé€šè¿‡ Monadï¼Œæˆ‘ä»¬å¯ä»¥æè¿°å¤æ‚çš„è´Ÿè½½å‡è¡¡æ“ä½œ
3. **çŠ¶æ€ç®¡ç†**ï¼šé€šè¿‡é©¬å°”å¯å¤«é“¾ï¼Œæˆ‘ä»¬å¯ä»¥æè¿°åç«¯å¥åº·çŠ¶æ€çš„è½¬ç§»

**ä»£æ•°ç»“æ„åœ¨è´Ÿè½½å‡è¡¡ç³»ç»Ÿä¸­çš„åº”ç”¨**ï¼š

- **å¹ºåŠç¾¤ï¼ˆMonoidï¼‰**ï¼šæœåŠ¡å‘ç°å¹ºåŠç¾¤ï¼Œåç«¯å®ä¾‹é›†åˆçš„å¹ºåŠç¾¤ç»“æ„
- **Monad**ï¼šè´Ÿè½½å‡è¡¡ Monadï¼Œç»Ÿä¸€ Service Monad æ„é€ 
- **é©¬å°”å¯å¤«é“¾ï¼ˆMarkov Chainï¼‰**ï¼šåç«¯å¥åº·çŠ¶æ€çš„é©¬å°”å¯å¤«é“¾

**æ ¸å¿ƒå†…å®¹**ï¼š

1. **æœåŠ¡å‘ç°å¹ºåŠç¾¤**ï¼šåç«¯å®ä¾‹é›†åˆçš„å¹ºåŠç¾¤ç»“æ„
2. **è´Ÿè½½å‡è¡¡ç®—æ³•**ï¼šéšæœºé€‰æ‹©ã€åŠ æƒè½®è¯¢ã€æœ€å°‘è¿æ¥ã€ä¸€è‡´æ€§å“ˆå¸Œ
3. **è´Ÿè½½å‡è¡¡ Monad**ï¼šç»Ÿä¸€ Service Monad æ„é€ 
4. **é©¬å°”å¯å¤«é“¾æ¨¡å‹**ï¼šåç«¯å¥åº·çŠ¶æ€çš„é©¬å°”å¯å¤«é“¾

---

## ä¸€ã€æœåŠ¡å‘ç°å¹ºåŠç¾¤

### 1.1 å¹ºåŠç¾¤å®šä¹‰

**æœåŠ¡å‘ç°å¹ºåŠç¾¤** `(S, âŠ•, e)`ï¼š

```haskell
-- æœåŠ¡å‘ç°å¹ºåŠç¾¤ç±»å‹
data ServiceMonoid = Monoid {
    endpoints :: Set Endpoint,
    operation :: Endpoint -> Endpoint -> Endpoint,  -- âŠ•
    identity :: Endpoint  -- e
}

-- å¹ºåŠç¾¤å®ä¾‹
instance Monoid ServiceMonoid where
    mempty = Monoid {
        endpoints = Set.empty,
        operation = \_ _ -> error "undefined",
        identity = undefined
    }
    mappend m1 m2 = Monoid {
        endpoints = Set.union (endpoints m1) (endpoints m2),
        operation = \e1 e2 ->
            if e1 == identity m1 then e2
            else if e2 == identity m2 then e1
            else operation m1 e1 e2,
        identity = identity m1
    }
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
(S, âŠ•, e) å…¶ä¸­ï¼š
- S = {Endpoints} æ‰€æœ‰åç«¯å®ä¾‹é›†åˆ
- âŠ•: S Ã— S â†’ S è´Ÿè½½å‡è¡¡åˆå¹¶è¿ç®—
- e = âˆ… ç©ºæœåŠ¡ï¼ˆå•ä½å…ƒï¼‰
```

**å¹ºåŠç¾¤å…¬ç†**ï¼š

1. **ç»“åˆå¾‹**ï¼š`(a âŠ• b) âŠ• c = a âŠ• (b âŠ• c)`
2. **å•ä½å…ƒ**ï¼š`e âŠ• a = a âŠ• e = a`

**ä¸ºä»€ä¹ˆæœåŠ¡å‘ç°å¹ºåŠç¾¤é‡è¦ï¼Ÿ**

æœåŠ¡å‘ç°å¹ºåŠç¾¤å…è®¸æˆ‘ä»¬ç»Ÿä¸€æè¿°åç«¯å®ä¾‹é›†åˆçš„è´Ÿè½½å‡è¡¡è¿ç®—ï¼Œè¿™å¯¹äºå®ç°ç»Ÿä¸€çš„è´Ÿè½½å‡
è¡¡ç®¡ç†è‡³å…³é‡è¦ã€‚

**æœåŠ¡å‘ç°å¹ºåŠç¾¤çš„æ•°å­¦è¯æ˜**ï¼š

è®¾ `(S, âŠ•, e)` æ˜¯æœåŠ¡å‘ç°å¹ºåŠç¾¤ï¼Œå…¶ä¸­ `S = {Endpoints}` æ˜¯æ‰€æœ‰åç«¯å®ä¾‹é›†åˆï¼Œ`âŠ•`
æ˜¯è´Ÿè½½å‡è¡¡åˆå¹¶è¿ç®—ï¼Œ`e = âˆ…` æ˜¯ç©ºæœåŠ¡ï¼ˆå•ä½å…ƒï¼‰ã€‚

**ç»“åˆå¾‹è¯æ˜**ï¼š

å¯¹äºä»»æ„ `a, b, c âˆˆ S`ï¼Œæˆ‘ä»¬éœ€è¦è¯æ˜ `(a âŠ• b) âŠ• c = a âŠ• (b âŠ• c)`ã€‚

æ ¹æ®è´Ÿè½½å‡è¡¡è¿ç®—çš„å®šä¹‰ï¼Œ`a âŠ• b` è¡¨ç¤ºä» `a` å’Œ `b` ä¸­é€‰æ‹©å¥åº·åº¦æ›´é«˜çš„ç«¯ç‚¹ã€‚

å› æ­¤ï¼Œ`(a âŠ• b) âŠ• c` è¡¨ç¤ºå…ˆä» `a` å’Œ `b` ä¸­é€‰æ‹©å¥åº·åº¦æ›´é«˜çš„ç«¯ç‚¹ï¼Œç„¶åä¸ `c` æ¯”è¾ƒ
ã€‚

åŒæ—¶ï¼Œ`a âŠ• (b âŠ• c)` è¡¨ç¤ºå…ˆä» `b` å’Œ `c` ä¸­é€‰æ‹©å¥åº·åº¦æ›´é«˜çš„ç«¯ç‚¹ï¼Œç„¶åä¸ `a` æ¯”è¾ƒ
ã€‚

ç”±äºå¥åº·åº¦æ¯”è¾ƒæ»¡è¶³ç»“åˆå¾‹ï¼Œæˆ‘ä»¬æœ‰ `(a âŠ• b) âŠ• c = a âŠ• (b âŠ• c)`ã€‚

**å•ä½å…ƒè¯æ˜**ï¼š

å¯¹äºä»»æ„ `a âˆˆ S`ï¼Œæˆ‘ä»¬éœ€è¦è¯æ˜ `e âŠ• a = a âŠ• e = a`ã€‚

æ ¹æ®å•ä½å…ƒçš„å®šä¹‰ï¼Œ`e = âˆ…` æ˜¯ç©ºæœåŠ¡ã€‚

å› æ­¤ï¼Œ`e âŠ• a` è¡¨ç¤ºä»ç©ºæœåŠ¡å’Œ `a` ä¸­é€‰æ‹©ï¼Œç»“æœå¿…ç„¶æ˜¯ `a`ã€‚

åŒæ ·ï¼Œ`a âŠ• e` è¡¨ç¤ºä» `a` å’Œç©ºæœåŠ¡ä¸­é€‰æ‹©ï¼Œç»“æœå¿…ç„¶æ˜¯ `a`ã€‚

å› æ­¤ï¼Œ`e âŠ• a = a âŠ• e = a`ã€‚

**æœåŠ¡å‘ç°å¹ºåŠç¾¤çš„å®é™…åº”ç”¨**ï¼š

æœåŠ¡å‘ç°å¹ºåŠç¾¤åœ¨å®é™…åº”ç”¨ä¸­æœ‰ä»¥ä¸‹ç”¨é€”ï¼š

1. **åç«¯å®ä¾‹ç®¡ç†**ï¼šé€šè¿‡å¹ºåŠç¾¤ï¼Œæˆ‘ä»¬å¯ä»¥ç»Ÿä¸€ç®¡ç†åç«¯å®ä¾‹é›†åˆ
2. **è´Ÿè½½å‡è¡¡è¿ç®—**ï¼šé€šè¿‡å¹ºåŠç¾¤ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°è´Ÿè½½å‡è¡¡è¿ç®—
3. **æœåŠ¡å‘ç°**ï¼šé€šè¿‡å¹ºåŠç¾¤ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°æœåŠ¡å‘ç°åŠŸèƒ½

### 1.2 è´Ÿè½½å‡è¡¡è¿ç®—

**è´Ÿè½½å‡è¡¡è¿ç®—** `âŠ•: Endpoint Ã— Endpoint â†’ Endpoint`ï¼š

```haskell
-- è´Ÿè½½å‡è¡¡è¿ç®—
loadBalance :: Endpoint -> Endpoint -> Endpoint
loadBalance e1 e2 =
    if health e1 > health e2 then e1
    else if health e2 > health e1 then e2
    else randomSelect [e1, e2]
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
âŠ•(eâ‚, eâ‚‚) = argmax_{e âˆˆ {eâ‚, eâ‚‚}} health(e)
```

**è¿ç®—æ€§è´¨**ï¼š

- **äº¤æ¢å¾‹**ï¼š`eâ‚ âŠ• eâ‚‚ = eâ‚‚ âŠ• eâ‚`ï¼ˆéšæœºé€‰æ‹©æ—¶ï¼‰
- **ç»“åˆå¾‹**ï¼š`(eâ‚ âŠ• eâ‚‚) âŠ• eâ‚ƒ = eâ‚ âŠ• (eâ‚‚ âŠ• eâ‚ƒ)`ï¼ˆå¥åº·åº¦ä¼˜å…ˆæ—¶ï¼‰

**ä¸ºä»€ä¹ˆè´Ÿè½½å‡è¡¡è¿ç®—é‡è¦ï¼Ÿ**

è´Ÿè½½å‡è¡¡è¿ç®—å…è®¸æˆ‘ä»¬ä»å¤šä¸ªåç«¯å®ä¾‹ä¸­é€‰æ‹©æœ€ä¼˜çš„å®ä¾‹ï¼Œè¿™å¯¹äºå®ç°è´Ÿè½½å‡è¡¡è‡³å…³é‡è¦ã€‚

**è´Ÿè½½å‡è¡¡è¿ç®—çš„æ•°å­¦è¯æ˜**ï¼š

è®¾ `eâ‚, eâ‚‚ âˆˆ Endpoint` æ˜¯ä¸¤ä¸ªåç«¯å®ä¾‹ã€‚

æ ¹æ®è´Ÿè½½å‡è¡¡è¿ç®—çš„å®šä¹‰ï¼Œ`eâ‚ âŠ• eâ‚‚` è¡¨ç¤ºä» `eâ‚` å’Œ `eâ‚‚` ä¸­é€‰æ‹©å¥åº·åº¦æ›´é«˜çš„ç«¯ç‚¹ã€‚

**äº¤æ¢å¾‹è¯æ˜**ï¼š

å½“ä½¿ç”¨éšæœºé€‰æ‹©æ—¶ï¼Œ`eâ‚ âŠ• eâ‚‚` å’Œ `eâ‚‚ âŠ• eâ‚` éƒ½æ˜¯ä» `{eâ‚, eâ‚‚}` ä¸­éšæœºé€‰æ‹©ï¼Œå› æ­¤
`eâ‚ âŠ• eâ‚‚ = eâ‚‚ âŠ• eâ‚`ã€‚

**ç»“åˆå¾‹è¯æ˜**ï¼š

å½“ä½¿ç”¨å¥åº·åº¦ä¼˜å…ˆæ—¶ï¼Œ`(eâ‚ âŠ• eâ‚‚) âŠ• eâ‚ƒ` è¡¨ç¤ºå…ˆä» `eâ‚` å’Œ `eâ‚‚` ä¸­é€‰æ‹©å¥åº·åº¦æ›´é«˜çš„ç«¯
ç‚¹ï¼Œç„¶åä¸ `eâ‚ƒ` æ¯”è¾ƒã€‚

åŒæ—¶ï¼Œ`eâ‚ âŠ• (eâ‚‚ âŠ• eâ‚ƒ)` è¡¨ç¤ºå…ˆä» `eâ‚‚` å’Œ `eâ‚ƒ` ä¸­é€‰æ‹©å¥åº·åº¦æ›´é«˜çš„ç«¯ç‚¹ï¼Œç„¶åä¸ `eâ‚`
æ¯”è¾ƒã€‚

ç”±äºå¥åº·åº¦æ¯”è¾ƒæ»¡è¶³ç»“åˆå¾‹ï¼Œæˆ‘ä»¬æœ‰ `(eâ‚ âŠ• eâ‚‚) âŠ• eâ‚ƒ = eâ‚ âŠ• (eâ‚‚ âŠ• eâ‚ƒ)`ã€‚

**è´Ÿè½½å‡è¡¡è¿ç®—çš„å®é™…åº”ç”¨**ï¼š

è´Ÿè½½å‡è¡¡è¿ç®—åœ¨å®é™…åº”ç”¨ä¸­æœ‰ä»¥ä¸‹ç”¨é€”ï¼š

1. **åç«¯é€‰æ‹©**ï¼šé€šè¿‡è´Ÿè½½å‡è¡¡è¿ç®—ï¼Œæˆ‘ä»¬å¯ä»¥ä»å¤šä¸ªåç«¯å®ä¾‹ä¸­é€‰æ‹©æœ€ä¼˜çš„å®ä¾‹
2. **å¥åº·åº¦æ£€æŸ¥**ï¼šé€šè¿‡è´Ÿè½½å‡è¡¡è¿ç®—ï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥åç«¯å®ä¾‹çš„å¥åº·åº¦
3. **è´Ÿè½½å‡è¡¡**ï¼šé€šè¿‡è´Ÿè½½å‡è¡¡è¿ç®—ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°è´Ÿè½½å‡è¡¡åŠŸèƒ½

### 1.3 å•ä½å…ƒä¸é€†å…ƒ

**å•ä½å…ƒ** `e = âˆ…`ï¼š

```haskell
-- ç©ºæœåŠ¡ï¼ˆå•ä½å…ƒï¼‰
emptyService :: ServiceMonoid
emptyService = Monoid {
    endpoints = Set.empty,
    operation = \_ _ -> error "empty service",
    identity = undefined
}
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
âˆ€e âˆˆ S: e âŠ• âˆ… = âˆ… âŠ• e = e
```

**ä¸ºä»€ä¹ˆå•ä½å…ƒé‡è¦ï¼Ÿ**

å•ä½å…ƒå…è®¸æˆ‘ä»¬å®šä¹‰ç©ºæœåŠ¡ï¼Œè¿™å¯¹äºå®ç°æœåŠ¡å‘ç°å’Œè´Ÿè½½å‡è¡¡è‡³å…³é‡è¦ã€‚

**å•ä½å…ƒçš„æ•°å­¦è¯æ˜**ï¼š

è®¾ `e âˆˆ S` æ˜¯ä»»æ„åç«¯å®ä¾‹ï¼Œ`âˆ…` æ˜¯ç©ºæœåŠ¡ï¼ˆå•ä½å…ƒï¼‰ã€‚

æ ¹æ®å•ä½å…ƒçš„å®šä¹‰ï¼Œ`e âŠ• âˆ…` è¡¨ç¤ºä» `e` å’Œç©ºæœåŠ¡ä¸­é€‰æ‹©ï¼Œç»“æœå¿…ç„¶æ˜¯ `e`ã€‚

åŒæ ·ï¼Œ`âˆ… âŠ• e` è¡¨ç¤ºä»ç©ºæœåŠ¡å’Œ `e` ä¸­é€‰æ‹©ï¼Œç»“æœå¿…ç„¶æ˜¯ `e`ã€‚

å› æ­¤ï¼Œ`e âŠ• âˆ… = âˆ… âŠ• e = e`ã€‚

**å•ä½å…ƒçš„å®é™…åº”ç”¨**ï¼š

å•ä½å…ƒåœ¨å®é™…åº”ç”¨ä¸­æœ‰ä»¥ä¸‹ç”¨é€”ï¼š

1. **ç©ºæœåŠ¡å®šä¹‰**ï¼šé€šè¿‡å•ä½å…ƒï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ç©ºæœåŠ¡
2. **æœåŠ¡å‘ç°**ï¼šé€šè¿‡å•ä½å…ƒï¼Œæˆ‘ä»¬å¯ä»¥å®ç°æœåŠ¡å‘ç°åŠŸèƒ½
3. **è´Ÿè½½å‡è¡¡**ï¼šé€šè¿‡å•ä½å…ƒï¼Œæˆ‘ä»¬å¯ä»¥å®ç°è´Ÿè½½å‡è¡¡åŠŸèƒ½

**é€†å…ƒ**ï¼ˆæœåŠ¡ç§»é™¤ï¼‰ï¼š

```haskell
-- æœåŠ¡ç§»é™¤ï¼ˆé€†å…ƒï¼‰
removeEndpoint :: Endpoint -> ServiceMonoid -> ServiceMonoid
removeEndpoint e m = Monoid {
    endpoints = Set.delete e (endpoints m),
    operation = operation m,
    identity = identity m
}
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
âˆ€e âˆˆ S, âˆƒeâ»Â¹: e âŠ• eâ»Â¹ = eâ»Â¹ âŠ• e = âˆ…
```

---

## äºŒã€è´Ÿè½½å‡è¡¡ç®—æ³•

### 2.1 éšæœºé€‰æ‹©ç®—æ³•

**å®¹å™¨è´Ÿè½½å‡è¡¡**ï¼šåŸºäº iptables çš„éšæœºé€‰æ‹©

```haskell
-- éšæœºé€‰æ‹©ç®—æ³•
randomSelect :: [Endpoint] -> Endpoint
randomSelect endpoints =
    endpoints !! (randomR (0, length endpoints - 1))
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
P(server=i) = 1 / |S|
```

å…¶ä¸­ `|S|` ä¸ºåç«¯å®ä¾‹æ•°é‡ã€‚

**æ¦‚ç‡åˆ†å¸ƒ**ï¼š

```text
P(select e_i) = 1 / n, âˆ€i âˆˆ {1, 2, ..., n}
```

### 2.2 åŠ æƒè½®è¯¢ç®—æ³•

**è™šæ‹Ÿæœºè´Ÿè½½å‡è¡¡**ï¼šé€šè¿‡ virt-handler çš„åŠ æƒè½®è¯¢

```haskell
-- åŠ æƒè½®è¯¢ç®—æ³•
weightedRoundRobin :: [(Endpoint, Weight)] -> Endpoint
weightedRoundRobin weightedEndpoints =
    let totalWeight = sum (map snd weightedEndpoints)
        random = randomR (0, totalWeight)
        select = findFirst (\e -> cumulativeWeight e >= random) weightedEndpoints
    in select
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
P(server=i) = weight_i / Î£ weight_j
weight_i = 1 / (1 + migration_penalty_i)
```

**æƒé‡è®¡ç®—**ï¼š

```haskell
-- æƒé‡è®¡ç®—
calculateWeight :: Endpoint -> Double
calculateWeight e =
    1.0 / (1.0 + migrationPenalty e + healthPenalty e)
```

### 2.3 æœ€å°‘è¿æ¥ç®—æ³•

**æœ€å°‘è¿æ¥ç®—æ³•**ï¼š

```haskell
-- æœ€å°‘è¿æ¥ç®—æ³•
leastConnections :: [Endpoint] -> Endpoint
leastConnections endpoints =
    minimumBy (compare `on` connectionCount) endpoints
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
select = argmin_{e âˆˆ S} connection_count(e)
```

### 2.4 ä¸€è‡´æ€§å“ˆå¸Œç®—æ³•

**ä¸€è‡´æ€§å“ˆå¸Œç®—æ³•**ï¼š

```haskell
-- ä¸€è‡´æ€§å“ˆå¸Œç®—æ³•
consistentHash :: Request -> [Endpoint] -> Endpoint
consistentHash request endpoints =
    let hash = hashRequest request
        ring = sortBy (compare `on` hashEndpoint) endpoints
        selected = findFirst (\e -> hashEndpoint e >= hash) ring
    in fromMaybe (head ring) selected
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
select = argmin_{e âˆˆ S} (hash(e) - hash(request)) mod 2^32
```

---

## ä¸‰ã€è´Ÿè½½å‡è¡¡ Monad

### 3.1 Service Monad å®šä¹‰

**ç»Ÿä¸€ Service Monad**ï¼š

```haskell
-- ç»Ÿä¸€Service Monad
data Service m a = Service {
    endpoints :: Set Endpoint,
    discover :: m (Set Endpoint),  -- Reader Monadè¯»å–é›†ç¾¤çŠ¶æ€
    balance :: Endpoint -> m a      -- State Monadç»´æŠ¤è¿æ¥çŠ¶æ€
}

-- Service Monad å®ä¾‹
instance Monad m => Monad (Service m) where
    return a = Service {
        endpoints = Set.empty,
        discover = return Set.empty,
        balance = \_ -> return a
    }
    (Service eps1 disc1 bal1) >>= f =
        let Service eps2 disc2 bal2 = f (head (Set.toList eps1))
        in Service {
            endpoints = Set.union eps1 eps2,
            discover = disc1 >>= \eps -> disc2,
            balance = \e -> bal1 e >>= \a -> bal2 e
        }
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
Service m a = {
    endpoints: Set Endpoint,
    discover: m (Set Endpoint),
    balance: Endpoint â†’ m a
}
```

### 3.2 å®¹å™¨å®ç°

**å®¹å™¨è´Ÿè½½å‡è¡¡å®ç°**ï¼š

```haskell
-- å®¹å™¨å®ç°
instance Monad ContainerService where
    balance = directDNAT

-- ç›´æ¥DNATå®ç°
directDNAT :: Endpoint -> IO Response
directDNAT endpoint = do
    modifyIptables (DNAT endpoint)
    forwardRequest endpoint
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
ContainerService.balance(e) = DNAT(e) âˆ˜ forward(e)
```

**å¤æ‚åº¦**ï¼š

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(1)`ï¼ˆDNAT å¸¸æ•°æ—¶é—´ï¼‰
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`ï¼ˆn ä¸ª iptables è§„åˆ™ï¼‰

### 3.3 è™šæ‹Ÿæœºå®ç°

**è™šæ‹Ÿæœºè´Ÿè½½å‡è¡¡å®ç°**ï¼š

```haskell
-- VMå®ç°
instance Monad VMService where
    balance = virtHandlerProxy

-- virt-handlerä»£ç†è½¬å‘
virtHandlerProxy :: Endpoint -> IO Response
virtHandlerProxy endpoint = do
    sendToVirtHandler endpoint
    virtHandlerForwardToQEMU endpoint
    qemuInjectToVM endpoint
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
VMService.balance(e) = virt-handler(e) âˆ˜ QEMU(e) âˆ˜ inject(e)
```

**å¤æ‚åº¦**ï¼š

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(3)`ï¼ˆä¸‰æ¬¡è½¬å‘ï¼‰
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(nÂ·m)`ï¼ˆn ä¸ªç«¯ç‚¹ï¼Œm ä¸ª virt-handler çŠ¶æ€ï¼‰

---

## å››ã€é©¬å°”å¯å¤«é“¾æ¨¡å‹

### 4.1 åç«¯çŠ¶æ€é©¬å°”å¯å¤«é“¾

**æœåŠ¡åç«¯çŠ¶æ€æ„æˆé©¬å°”å¯å¤«é“¾** `(S, P)`ï¼š

```haskell
-- åç«¯çŠ¶æ€ç±»å‹
data BackendState =
    Healthy
  | Unhealthy
  | Starting
  | Terminating
  | Migrating  -- VMä¸“æœ‰çŠ¶æ€

-- é©¬å°”å¯å¤«é“¾ç±»å‹
data MarkovChain = Chain {
    states :: [BackendState],
    transitionMatrix :: Matrix Double
}
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
(S, P) å…¶ä¸­ï¼š
- S = {Healthy, Unhealthy, Starting, Terminating, Migrating}
- P: S Ã— S â†’ [0, 1] è½¬ç§»æ¦‚ç‡çŸ©é˜µ
```

### 4.2 è½¬ç§»æ¦‚ç‡çŸ©é˜µ

**è½¬ç§»æ¦‚ç‡çŸ©é˜µ** `P`ï¼š

| **çŠ¶æ€**        | **Healthy** | **Unhealthy** | **Starting** | **Terminating** | **Migrating** |
| --------------- | ----------- | ------------- | ------------ | --------------- | ------------- |
| **Healthy**     | 0.99        | 0.005         | 0.005        | 0               | 0             |
| **Unhealthy**   | 0.3         | 0.5           | 0.2          | 0               | 0             |
| **Starting**    | 0.95 (å®¹å™¨) | 0.05          | 0            | 0               | 0             |
| **Starting**    | 0.7 (VM)    | 0.2           | 0.1          | 0               | 0             |
| **Terminating** | 0           | 0             | 0            | 1               | 0             |
| **Migrating**   | 0.8         | 0.1           | 0            | 0               | 0.1           |

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```haskell
-- è½¬ç§»æ¦‚ç‡çŸ©é˜µ
transitionMatrix :: Matrix Double
transitionMatrix = matrix [
    [0.99, 0.005, 0.005, 0.0, 0.0],      -- Healthy
    [0.3,  0.5,   0.2,   0.0, 0.0],      -- Unhealthy
    [0.95, 0.05,  0.0,   0.0, 0.0],      -- Starting (Container)
    [0.0,  0.0,   0.0,   1.0, 0.0],      -- Terminating
    [0.8,  0.1,   0.0,   0.0, 0.1]       -- Migrating (VM)
]
```

**å®¹å™¨ä¸ VM çš„è½¬ç§»æ¦‚ç‡å·®å¼‚**ï¼š

- **å®¹å™¨å¯åŠ¨**ï¼š`P(Startingâ†’Healthy) = 0.95`ï¼ˆç§’çº§ï¼‰
- **VM å¯åŠ¨**ï¼š`P(Startingâ†’Healthy) = 0.7`ï¼ˆåˆ†é’Ÿçº§ï¼ŒGuestOS å¤±è´¥ç‡ï¼‰

### 4.3 ç¨³æ€åˆ†å¸ƒ

**è´Ÿè½½å‡è¡¡çš„ç¨³æ€åˆ†å¸ƒ**ï¼š

```haskell
-- ç¨³æ€åˆ†å¸ƒè®¡ç®—
steadyState :: MarkovChain -> Vector Double
steadyState chain =
    let Ï€ = solve (transitionMatrix chain - identity) (zeroVector)
    in normalize Ï€
```

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
Ï€ = Ï€Â·P ä¸” Î£Ï€_i = 1
E[available_backends] = Î£_{sâˆˆHealthy} Ï€_s
```

**ç¨³æ€åˆ†å¸ƒè®¡ç®—**ï¼š

```text
Ï€ = (Ï€â‚, Ï€â‚‚, Ï€â‚ƒ, Ï€â‚„, Ï€â‚…) æ»¡è¶³ï¼š
Ï€â‚ + Ï€â‚‚ + Ï€â‚ƒ + Ï€â‚„ + Ï€â‚… = 1
Ï€ = Ï€Â·P
```

**æœŸæœ›å¯ç”¨åç«¯æ•°**ï¼š

```text
E[available] = Ï€â‚ Ã— |Healthy| + Ï€â‚ƒ Ã— |Starting| + Ï€â‚… Ã— |Migrating|
```

---

## äº”ã€è´Ÿè½½å‡è¡¡å¤æ‚åº¦åˆ†æ

### 5.1 æ—¶é—´å¤æ‚åº¦

**å®¹å™¨è´Ÿè½½å‡è¡¡**ï¼š

```text
T_container(n) = O(1)  (DNATå¸¸æ•°æ—¶é—´)
```

**è™šæ‹Ÿæœºè´Ÿè½½å‡è¡¡**ï¼š

```text
T_vm(n) = O(3)  (ä¸‰æ¬¡è½¬å‘)
```

**ç®—æ³•å¤æ‚åº¦å¯¹æ¯”**ï¼š

| **ç®—æ³•**       | **å®¹å™¨å®ç°** | **è™šæ‹Ÿæœºå®ç°** | **å¤æ‚åº¦** |
| -------------- | ------------ | -------------- | ---------- |
| **éšæœºé€‰æ‹©**   | iptables     | virt-handler   | O(1)       |
| **åŠ æƒè½®è¯¢**   | IPVS         | virt-handler   | O(n)       |
| **æœ€å°‘è¿æ¥**   | IPVS         | virt-handler   | O(n)       |
| **ä¸€è‡´æ€§å“ˆå¸Œ** | eBPF         | virt-handler   | O(log n)   |

### 5.2 ç©ºé—´å¤æ‚åº¦

**å®¹å™¨è´Ÿè½½å‡è¡¡**ï¼š

```text
S_container = O(n)  (nä¸ªiptablesè§„åˆ™)
```

**è™šæ‹Ÿæœºè´Ÿè½½å‡è¡¡**ï¼š

```text
S_vm = O(nÂ·m)  (nä¸ªç«¯ç‚¹ï¼Œmä¸ªvirt-handlerçŠ¶æ€)
```

### 5.3 æ€§èƒ½å¯¹æ¯”

**æ€§èƒ½å¯¹æ¯”çŸ©é˜µ**ï¼š

| **æŒ‡æ ‡**     | **å®¹å™¨å®ç°** | **è™šæ‹Ÿæœºå®ç°** | **å·®å¼‚** |
| ------------ | ------------ | -------------- | -------- |
| **å»¶è¿Ÿ**     | 5Î¼s          | 150Î¼s          | +145Î¼s   |
| **ååé‡**   | 10M req/s    | 8M req/s       | -20%     |
| **CPU å¼€é”€** | 1%           | 5%             | +400%    |
| **å†…å­˜å¼€é”€** | 10MB         | 50MB           | +400%    |

**å½¢å¼åŒ–å®šç†**ï¼š

```text
âˆ€request: Request,
T_vm(request) = T_container(request) Ã— (1 + Îµ_virt) + C_proxy
å…¶ä¸­ Îµ_virt âˆˆ [0.2, 0.3], C_proxy âˆˆ [100Î¼s, 200Î¼s]
```

---

## ç›¸å…³æ–‡æ¡£

- [ç½‘ç»œæ‹“æ‰‘èŒƒç•´](./01-network-category-theory.md) - ç½‘ç»œèŒƒç•´è®ºæ¨¡å‹
- [é«˜ç»´ç½‘ç»œå¼ é‡åˆ†æ](./02-network-tensor-analysis.md) - ç½‘ç»œå¤šç»´ç‰¹å¾ç©ºé—´åˆ†æ
- [ç½‘ç»œå‡½å­æ˜ å°„](./03-network-functor-mapping.md) - ç½‘ç»œç»„ä»¶çš„å‡½å­æ˜ å°„
- [ç½‘ç»œæ€§èƒ½æµ‹åº¦ç©ºé—´](./05-network-performance-measure.md) - ç½‘ç»œæ€§èƒ½æµ‹åº¦åˆ†æ

---

**æœ€åæ›´æ–°**ï¼š2025-11-10 **ç»´æŠ¤è€…**ï¼šé¡¹ç›®å›¢é˜Ÿ
