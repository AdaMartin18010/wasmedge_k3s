# 系统软件层调度：OS 进程调度与内存调度

> **文档版本**：v1.0 **最后更新**：2025-11-10 **维护者**：项目团队

---

## 📑 目录

- [📑 目录](#-目录)
- [1 概述](#1-概述)
- [2 进程调度](#2-进程调度)
  - [2.1 Linux CFS 调度器形式化分析](#21-linux-cfs-调度器形式化分析)
  - [2.2 调度策略对比](#22-调度策略对比)
  - [2.3 实时调度](#23-实时调度)
- [3 线程调度](#3-线程调度)
  - [3.1 M:N 线程模型](#31-mn-线程模型)
  - [3.2 线程调度策略](#32-线程调度策略)
- [4 内存调度](#4-内存调度)
  - [4.1 虚拟内存调度](#41-虚拟内存调度)
  - [4.2 页面置换算法](#42-页面置换算法)
  - [4.3 缓存调度](#43-缓存调度)
- [5 形式化证明](#5-形式化证明)
  - [5.1 CFS 公平性定理](#51-cfs-公平性定理)
  - [5.2 可调度性分析](#52-可调度性分析)
- [6 性能优化](#6-性能优化)
  - [6.1 调度参数调优](#61-调度参数调优)
  - [6.2 NUMA 感知调度](#62-numa-感知调度)
- [7 实际应用](#7-实际应用)
  - [7.1 Linux 调度实践](#71-linux-调度实践)
  - [7.2 性能调优案例](#72-性能调优案例)
- [8 相关文档](#8-相关文档)
- [9 参考](#9-参考)
  - [学术参考](#学术参考)
  - [实践参考](#实践参考)

---

## 1 概述

**系统软件层调度**是操作系统在进程、线程、内存等资源层面的调度机制，负责管理 CPU
时间片分配、内存页面置换、缓存替换等。

**核心目标**：

1. **公平性**：公平分配 CPU 时间给各个进程
2. **响应性**：保证交互式应用的响应时间
3. **吞吐量**：最大化系统整体吞吐量
4. **实时性**：满足实时任务的截止时间要求

**为什么需要系统软件层调度分析？**

系统软件层调度是应用性能的基础，理解系统软件层调度原理有助于：

- **性能优化**：理解系统调度行为，优化应用性能
- **问题诊断**：诊断性能问题的系统层面原因
- **系统调优**：调整系统调度参数优化整体性能

---

## 2 进程调度

### 2.1 Linux CFS 调度器形式化分析

**虚拟运行时间**：

$$
vruntime_i = \sum_{k=1}^{n} \frac{actual\_runtime_i(k) \times weight\_nice0}{weight_i}
$$

其中：

- $actual\_runtime_i(k)$：进程 $i$ 在第 $k$ 个调度周期内的实际运行时间
- $weight_i$：进程 $i$ 的权重（由 nice 值决定）
- $weight\_nice0$：nice=0 的进程权重

**调度决策函数**：

$$
\text{PickNext}() = \arg\min_{t \in ReadyQueue} vruntime(t)
$$

调度器总是选择 vruntime 最小的进程运行。

**公平性定理**：

$$
\forall t_i, t_j, \quad \lim_{T\to\infty} \frac{runtime_i(T)}{weight_i} = \frac{runtime_j(T)}{weight_j}
$$

**证明**：

- 构造离散时间系统，每个调度周期更新 vruntime
- 使用数学归纳法证明 vruntime 差值有界
- 由红黑树数据结构保证 $O(\log n)$ 查找复杂度

**调度延迟**：

$$
sched\_latency = \frac{\text{目标延迟}}{\text{就绪进程数}}
$$

当就绪进程数较少时，所有进程在一个调度周期内都能运行。

### 2.2 调度策略对比

| 调度策略                               | 特点         | 适用场景   | 复杂度   |
| -------------------------------------- | ------------ | ---------- | -------- |
| **FIFO**                               | 先来先服务   | 批处理任务 | O(1)     |
| **RR（Round Robin）**                  | 时间片轮转   | 交互式应用 | O(1)     |
| **CFS（Completely Fair Scheduler）**   | 完全公平调度 | 通用场景   | O(log n) |
| **MLFQ（Multi-Level Feedback Queue）** | 多级反馈队列 | 混合负载   | O(1)     |

**CFS 优势**：

- **公平性**：保证所有进程按权重比例获得 CPU 时间
- **低延迟**：交互式进程能够及时响应
- **可扩展性**：红黑树保证 $O(\log n)$ 复杂度

### 2.3 实时调度

**实时调度策略**：

1. **SCHED_FIFO**：先进先出，高优先级进程可以抢占低优先级进程
2. **SCHED_RR**：轮转调度，相同优先级进程按时间片轮转
3. **SCHED_DEADLINE**：截止时间调度，保证任务在截止时间前完成

**可调度性分析**：

对于周期性实时任务集合 $\{\tau_1, ..., \tau_n\}$，使用速率单调调度（RMS）可调度
的充要条件：

$$
\sum_{i=1}^{n} \frac{C_i}{T_i} \le n(2^{1/n} - 1)
$$

其中 $C_i$ 为任务执行时间，$T_i$ 为任务周期。

---

## 3 线程调度

### 3.1 M:N 线程模型

**定义**：M:N 线程模型是 $M$ 个用户线程映射到 $N$ 个内核线程的模型。

**Golang GMP 模型**：

- **G（Goroutine）**：用户线程，轻量级（2KB 栈）
- **M（Machine）**：内核线程，对应 OS 线程
- **P（Processor）**：逻辑处理器，$|P| = \text{GOMAXPROCS}$

**优势**：

- **高并发**：可以创建百万级 Goroutine
- **低开销**：Goroutine 切换开销 ~30ns
- **自动调度**：工作窃取算法自动负载均衡

### 3.2 线程调度策略

**1:1 模型**：

每个用户线程对应一个内核线程，简单但开销大。

**N:1 模型**：

所有用户线程映射到一个内核线程，开销小但无法利用多核。

**M:N 模型**：

平衡并发度和开销，但实现复杂。

---

## 4 内存调度

### 4.1 虚拟内存调度

**页面调度**：

当物理内存不足时，需要将部分页面换出到磁盘。

**页面置换策略**：

- **FIFO**：先进先出
- **LRU**：最近最少使用
- **LFU**：最不经常使用
- **Clock**：时钟算法

### 4.2 页面置换算法

**LRU 算法**：

选择最近最久未使用的页面置换。

**形式化定义**：

$$
\text{LRU}(page) = \arg\max_{p \in Memory} \text{LastAccessTime}(p)
$$

**实现方式**：

- **硬件支持**：使用访问位和修改位
- **软件实现**：使用链表或栈维护访问顺序

**Clock 算法**：

LRU 的近似实现，使用循环链表和访问位。

### 4.3 缓存调度

**缓存替换策略**：

- **LRU**：最近最少使用
- **LFU**：最不经常使用
- **FIFO**：先进先出
- **Random**：随机替换

**缓存性能**：

$$
\text{缓存命中率} = \frac{\text{缓存命中次数}}{\text{总访问次数}}
$$

$$
\text{平均访问时间} = \text{命中率} \times T_{cache} + (1-\text{命中率}) \times T_{memory}
$$

---

## 5 形式化证明

### 5.1 CFS 公平性定理

**定理**：CFS 调度器保证所有进程按权重比例获得 CPU 时间。

**证明**：

1. **vruntime 更新规则**：每个调度周期，运行进程的 vruntime 增加
   $\frac{runtime \times weight\_nice0}{weight}$
2. **选择规则**：总是选择 vruntime 最小的进程
3. **收敛性**：通过数学归纳法证明 vruntime 差值有界
4. **公平性**：长期运行后，所有进程的 $\frac{runtime}{weight}$ 趋于相等

### 5.2 可调度性分析

**速率单调调度（RMS）可调度性**：

对于 $n$ 个周期性实时任务，RMS 可调度的充要条件：

$$
U = \sum_{i=1}^{n} \frac{C_i}{T_i} \le n(2^{1/n} - 1)
$$

其中 $U$ 为系统利用率。

**最早截止时间优先（EDF）可调度性**：

EDF 可调度的充要条件：

$$
U = \sum_{i=1}^{n} \frac{C_i}{T_i} \le 1
$$

EDF 是最优的动态优先级调度算法。

---

## 6 性能优化

### 6.1 调度参数调优

**CFS 参数**：

- **sched_latency_ns**：目标调度延迟（默认 6ms）
- **min_granularity_ns**：最小时间片（默认 0.75ms）
- **wakeup_granularity_ns**：唤醒粒度（默认 1ms）

**调优原则**：

- **交互式应用**：减小调度延迟，提高响应性
- **批处理任务**：增大时间片，减少上下文切换

### 6.2 NUMA 感知调度

**NUMA 架构**：

非统一内存访问（NUMA）架构中，访问本地内存比远程内存快。

**NUMA 调度策略**：

- **节点亲和性**：将进程绑定到特定 NUMA 节点
- **内存本地性**：优先在进程所在节点分配内存
- **负载均衡**：在 NUMA 节点间平衡负载

---

## 7 实际应用

### 7.1 Linux 调度实践

**进程优先级**：

- **Nice 值**：-20 到 19，值越小优先级越高
- **实时优先级**：1 到 99，值越大优先级越高

**CPU 亲和性**：

使用 `taskset` 或 `cpuset` 将进程绑定到特定 CPU 核心。

**调度策略选择**：

- **交互式应用**：使用默认 CFS
- **实时任务**：使用 SCHED_FIFO 或 SCHED_RR
- **批处理任务**：降低优先级（增大 nice 值）

### 7.2 性能调优案例

**案例 1：Web 服务器优化**：

- **问题**：响应延迟高
- **分析**：调度延迟导致请求处理延迟
- **优化**：减小 sched_latency_ns，提高交互式进程优先级

**案例 2：数据库优化**：

- **问题**：查询性能不稳定
- **分析**：NUMA 节点间内存访问导致性能波动
- **优化**：使用 NUMA 节点亲和性，将数据库进程绑定到特定节点

---

## 8 相关文档

- [调度视角 README.md](README.md) - 调度视角主索引
- [分层分析](03-layered-analysis.md) - 调度系统的分层架构分析
- [编程模型层调度](10-programming-model-scheduling.md) - 编程模型层调度分析
- [有界系统](07-bounded-system.md) - 调度系统的边界约束与稳定性

---

## 9 参考

### 学术参考

1. Liu, C. L., & Layland, J. W. (1973). "Scheduling Algorithms for
   Multiprogramming in a Hard-Real-Time Environment." _Journal of the ACM_.

2. Molnar, I. (2007). "CFS Scheduler." _Linux Kernel Documentation_.

### 实践参考

- [Linux Kernel Scheduler](https://www.kernel.org/doc/html/latest/scheduler/)
- [CFS Scheduler Design](https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt)

---

**最后更新**：2025-11-10 **维护者**：项目团队
