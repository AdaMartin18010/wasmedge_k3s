# QUICK-REFERENCE.md

## 📑 目录

- [QUICK-REFERENCE.md](#quick-referencemd)
  - [📑 目录](#-目录)
  - [📑 结构视角快速参考](#-结构视角快速参考)
    - [核心命题](#核心命题)
    - [三类结构](#三类结构)
    - [虚拟化容器化沙盒化](#虚拟化容器化沙盒化)
    - [选型格言](#选型格言)
    - [选型/迁移口诀](#选型迁移口诀)
    - [8 层结构权重（简化）](#8-层结构权重简化)
    - [故障模式](#故障模式)

---

## 📑 结构视角快速参考

### 核心命题

> **计算机科学 = 计算结构 ⊕ 控制结构 ⊕ 信息结构**

### 三类结构

| 结构类型     | 核心问题           | 典型实例                           |
| ------------ | ------------------ | ---------------------------------- |
| **计算结构** | "什么可以被计算？" | λ-演算、Monad、图灵机              |
| **控制结构** | "何时发生？"       | Happens-before、并发模型、事务隔离 |
| **信息结构** | "如何表示与逼近？" | 类型系统、抽象解释、容错计算       |

### 虚拟化容器化沙盒化

| 技术   | 结构重心          | 一句话总结                     |
| ------ | ----------------- | ------------------------------ |
| 虚拟化 | 重计算            | 重计算，全局序，信息全造假     |
| 容器化 | 折中（计算-控制） | syscall 换名字，镜像分层像拓扑 |
| 沙盒化 | 轻信息            | 不动计算，只剪权限，最小邻近集 |

### 选型格言

> **"你要多假的机器？"**
>
> - 想要**完全假的机器**→ 虚拟化（计算结构爆表）
> - 想要**差不多假的机器**→ 容器化（计算-控制折中）
> - 只想**别让程序坏事**→ 沙盒化（信息结构优先）

### 选型/迁移口诀

> **"向下买计算，向上买控制，向边买信息"**

- 需要**指令级兼容**→**往下走**：KVM/TEE
- 需要**毫秒级热迁移**→**控制轴加码**：Firecracker 微 VM
- 需要**镜像秒级分发**→**信息轴优化**：Docker 分层+压缩
- 需要**最小攻击面**→**信息轴剪枝**：seccomp + unveil + 线性内存

### 8 层结构权重（简化）

| 层级           | 计算  | 控制 | 信息 |
| -------------- | ----- | ---- | ---- |
| L8 业务代码    | ★★★☆  | ★★☆  | ★★   |
| L7 语言运行时  | ★★★   | ★★★  | ★★   |
| L6 LibOS       | ★★★   | ★★★☆ | ★★   |
| L5 容器引擎    | ★★    | ★★★★ | ★★★  |
| L4 Host Kernel | ★★    | ★★★  | ★★★  |
| L3 Hypervisor  | ★★★★  | ★★★  | ★★   |
| L2 Firmware    | ★★    | ★★★☆ | ★★★  |
| L1 Silicon     | ★★★★★ | ★★★  | ★    |

### 故障模式

| 故障            | 结构失衡       |
| --------------- | -------------- |
| Meltdown        | 信息结构崩溃   |
| Spectre         | 控制结构被利用 |
| Docker rm -rf / | 计算结构未隔离 |
| Java STW 卡顿   | 控制结构单点   |

## 💡 使用指南

### 技术选型决策流程

**步骤 1：识别结构需求**

- **计算结构需求**：需要什么计算能力？指令级兼容？性能要求？
- **控制结构需求**：需要什么控制能力？并发控制？事务隔离？
- **信息结构需求**：需要什么信息能力？类型安全？抽象层次？

**步骤 2：匹配技术方案**

- **计算结构优先**：选择虚拟化（KVM、Xen）
- **控制结构优先**：选择容器化（Docker、containerd）
- **信息结构优先**：选择沙盒化（seccomp、gVisor）

**步骤 3：验证结构平衡**

- **检查结构权重**：确保三层结构权重平衡
- **评估故障风险**：识别潜在的结构失衡点
- **优化结构设计**：调整技术选型以平衡结构

### 选型决策示例

**示例 1：高性能计算场景**

```
需求：高性能、指令级兼容
结构分析：
- 计算结构：★★★★★（需要最高性能）
- 控制结构：★★★（需要基本控制）
- 信息结构：★★（信息结构次要）

选型建议：虚拟化（KVM）+ 硬件直通
理由：计算结构优先，虚拟化提供完整指令级兼容
```

**示例 2：微服务架构场景**

```
需求：快速启动、资源隔离、服务网格
结构分析：
- 计算结构：★★（计算结构次要）
- 控制结构：★★★★（需要强控制能力）
- 信息结构：★★★（需要信息隔离）

选型建议：容器化（Docker）+ 沙盒化（seccomp）+ 服务网格（Istio）
理由：控制结构和信息结构并重，容器化提供快速启动
```

**示例 3：边缘计算场景**

```
需求：极低延迟、轻量级、边缘部署
结构分析：
- 计算结构：★★（计算结构次要）
- 控制结构：★★★（需要基本控制）
- 信息结构：★★★★（需要强信息隔离）

选型建议：WasmEdge + 沙盒化（seccomp）
理由：信息结构优先，WasmEdge 提供极低延迟和轻量级
```

### 迁移策略

**从虚拟化到容器化**：

- **向下迁移**：减少计算结构权重，增加控制结构权重
- **迁移步骤**：1) 应用容器化 2) 移除虚拟化层 3) 优化控制结构
- **注意事项**：确保信息结构隔离不降低

**从容器化到沙盒化**：

- **信息迁移**：增加信息结构权重，减少计算结构权重
- **迁移步骤**：1) 添加沙盒化层 2) 优化信息结构 3) 减少计算开销
- **注意事项**：确保控制结构能力不降低

## 🔍 常见问题

### Q1：如何判断结构失衡？

**判断标准**：

- **计算结构失衡**：性能不达标、指令不兼容
- **控制结构失衡**：并发问题、事务失败
- **信息结构失衡**：类型错误、抽象泄漏

### Q2：如何优化结构权重？

**优化方法**：

- **计算结构优化**：使用硬件加速、优化算法
- **控制结构优化**：使用并发控制、事务管理
- **信息结构优化**：使用类型系统、抽象层次

### Q3：三层结构如何平衡？

**平衡原则**：

- **根据场景调整**：不同场景需要不同的结构权重
- **避免过度优化**：不要过度优化某一层结构
- **保持整体平衡**：确保三层结构整体平衡

---

**更新时间**：2025-11-15 **版本**：v1.1
