# 混合架构设计：务实的"双轨制"

**版本**：v1.1 **最后更新：2025-11-15 **维护者**：项目团队

## 📑 目录

- [📑 目录](#-目录)
- [1 概述](#1-概述)
  - [1.1 核心问题](#11-核心问题)
  - [1.2 混合架构理论框架](#12-混合架构理论框架)
    - [1.2.1 互补性理论（Complementarity Theory）](#121-互补性理论complementarity-theory)
    - [1.2.2 架构演进理论（Architecture Evolution Theory）](#122-架构演进理论architecture-evolution-theory)
  - [1.3 核心观点](#13-核心观点)
- [2 架构原则：eBPF 负责"广度"，SDK 负责"深度"](#2-架构原则ebpf-负责广度sdk-负责深度)
  - [2.1 双轨制架构图](#21-双轨制架构图)
  - [2.2 双轨制配置示例](#22-双轨制配置示例)
  - [2.3 架构理论分析](#23-架构理论分析)
    - [2.3.1 关注点分离原则](#231-关注点分离原则)
    - [2.3.2 架构复杂度分析](#232-架构复杂度分析)
- [3 埋点策略矩阵：何时用 SDK vs eBPF](#3-埋点策略矩阵何时用-sdk-vs-ebpf)
  - [3.1 策略矩阵分析](#31-策略矩阵分析)
  - [3.2 决策模型](#32-决策模型)
  - [3.3 行业最佳实践](#33-行业最佳实践)
- [4 成熟度演进路线：从"混合"到"自治"](#4-成熟度演进路线从混合到自治)
  - [4.1 演进时间线](#41-演进时间线)
  - [4.2 演进驱动力分析](#42-演进驱动力分析)
  - [4.3 演进风险评估](#43-演进风险评估)
- [5 技术选型与风险缓解](#5-技术选型与风险缓解)
  - [5.1 技术选型决策树](#51-技术选型决策树)
    - [5.1.1 决策流程](#511-决策流程)
    - [5.1.2 2024 年推荐配置](#512-2024-年推荐配置)
  - [5.2 风险缓解策略](#52-风险缓解策略)
    - [5.2.1 风险 1：eBPF 程序导致内核不稳定](#521-风险-1ebpf-程序导致内核不稳定)
    - [5.2.2 风险 2：符号解析失败导致追踪断裂](#522-风险-2符号解析失败导致追踪断裂)
    - [5.2.3 风险 3：人才储备不足](#523-风险-3人才储备不足)
  - [5.3 案例研究](#53-案例研究)
    - [5.3.1 案例 1：大型互联网公司](#531-案例-1大型互联网公司)
    - [5.3.2 案例 2：金融科技公司](#532-案例-2金融科技公司)
- [6 结论与展望](#6-结论与展望)
  - [6.1 核心结论](#61-核心结论)
  - [6.2 理论意义](#62-理论意义)
  - [6.3 未来展望](#63-未来展望)
- [🔗 相关文档](#-相关文档)

---

## 1 概述

### 1.1 核心问题

传统可观测性架构存在以下问题：

- **单一方案局限性**：纯 SDK 方案无法覆盖内核层，纯 eBPF 方案无法理解业务语义
- **技术边界模糊**：不清楚何时使用 SDK，何时使用 eBPF
- **架构演进路径不明**：缺乏从混合架构到自治架构的清晰路径

### 1.2 混合架构理论框架

#### 1.2.1 互补性理论（Complementarity Theory）

根据互补性理论：

**互补关系**：

- **eBPF（广度）**：系统层、性能层、安全层
- **SDK（深度）**：业务层、应用层、逻辑层

**互补公式**：

```text
全栈可观测性 = eBPF(广度) + SDK(深度)
覆盖率 = eBPF覆盖率 × SDK覆盖率 / (eBPF覆盖率 + SDK覆盖率 - eBPF覆盖率 × SDK覆盖率)
```

#### 1.2.2 架构演进理论（Architecture Evolution Theory）

根据架构演进理论：

**演进阶段**：

- **阶段 1**：混合架构 1.0（70% eBPF + 30% SDK）
- **阶段 2**：混合架构 2.0（80% eBPF + 20% SDK）
- **阶段 3**：混合架构 3.0（85% eBPF + 15% SDK）
- **阶段 4**：混合架构 4.0（90% eBPF + 10% SDK）
- **阶段 5**：自治架构（95% eBPF + 5% SDK）

### 1.3 核心观点

**关键认知修正**：

❌ **错误认知**：eBPF+OTLP 将**完全省却**SDK，实现 100%零代码观测 ✅ **正确认
知**：eBPF+OTLP**增强**了观测能力，**减少**60-70%无意义埋点，但**无法替
代**30-40%核心业务语义

**核心边界界定**：

- **eBPF 无法省却的领域**：业务语义、跨节点关联、异步追踪、批处理关联
- **SDK 必须提供的领域**：业务实体语义、业务规则、业务事件、业务状态
- **混合架构原则**：**70% eBPF（广度） + 30% SDK（深度）** = **100% 全栈可观测**

---

## 2 架构原则：eBPF 负责"广度"，SDK 负责"深度"

### 2.1 双轨制架构图

**应用层（Business Layer）**：

- **SDK 埋点（深度语义）**：
  - OTel Logs SDK：业务事件（order.created）
  - OTel Tracing SDK：Span（createOrder, promo.apply）
  - OTel Metrics SDK：Custom Counter（orders.vip）

**系统层（System Layer）**：

- **eBPF DaemonSet（零侵入采集）**：
  - 自动日志：stdout/stderr
  - 自动指标：tcp_latency, cpu_usage
  - 自动追踪：tcp_connect span
  - 自动剖析：perf_event 采样
  - 自动审计：LSM file_open

**数据融合层（Fusion Layer）**：

- **OTLP Collector**：
  - SDK 日志 + eBPF 日志 → 统一 Log Stream
  - SDK Span + eBPF Span → 统一 Trace
  - SDK 指标 + eBPF 指标 → 统一 MetricSet
  - SDK Profile + eBPF Profile → 全栈火焰图

**埋点比例**：

- 日志：90% eBPF + 10% SDK（结构化业务事件）
- 追踪：30% eBPF + 70% SDK（业务语义为主）
- 指标：70% eBPF + 30% SDK（业务指标）

### 2.2 双轨制配置示例

```yaml
# values.yaml (Helm Chart)
# 混合配置：SDK + eBPF

opentelemetry-collector:
  mode: daemonset

  # eBPF Receiver (广度覆盖)
  receivers:
    ebpf:
      enabled: true
      programs:
        - name: tcp_connect
          type: kprobe
          sampling_rate: 1.0 # 全采样
        - name: file_open
          type: lsm
          sampling_rate: 0.1 # 10%采样
      autodiscovery:
        k8s_pod_labels: true
        container_id: true

    # OTLP SDK Receiver (深度语义)
    otlp:
      protocols:
        grpc:
          endpoint: 0.0.0.0:4317
        http:
          endpoint: 0.0.0.0:4318

  # 融合处理器
  processors:
    # 合并eBPF和SDK的Span
    span_merge:
      ebpf_span_source: "ebpf"
      sdk_span_source: "otlp"
      merge_strategy: "sdk_parent_ebpf_child"

    # 上下文关联
    resource:
      attributes:
        - key: k8s.pod.name
          from_attribute: ebpf.cgroup_id
          action: upsert
        - key: business.service.name
          from_attribute: otel.service.name
          action: upsert
```

### 2.3 架构理论分析

#### 2.3.1 关注点分离原则

根据关注点分离原则：

**eBPF 关注点**：

- **系统层**：内核函数、系统调用、网络包
- **性能层**：CPU、内存、I/O 性能
- **安全层**：文件访问、网络连接、进程创建

**SDK 关注点**：

- **业务层**：业务实体、业务规则、业务流程
- **应用层**：框架调用、ORM 映射、异步任务
- **逻辑层**：业务状态、业务事件、业务指标

#### 2.3.2 架构复杂度分析

**传统架构复杂度**：

```text
复杂度 = O(N × M)
其中：
- N = 服务数
- M = 观测组件数/服务
```

**混合架构复杂度**：

```text
复杂度 = O(K + N × P)
其中：
- K = 节点数（eBPF DaemonSet）
- N = 服务数
- P = SDK 组件数/服务（P << M）

当 N=100, M=6, K=10, P=2 时：
传统：600
混合：10 + 200 = 210
复杂度降低：65%
```

---

## 3 埋点策略矩阵：何时用 SDK vs eBPF

### 3.1 策略矩阵分析

| 观测需求        | eBPF 适用度 | SDK 适用度 | 推荐策略      | 埋点比例                            |
| --------------- | ----------- | ---------- | ------------- | ----------------------------------- |
| **系统资源**    | ⭐⭐⭐⭐⭐  | ⭐         | **纯 eBPF**   | 100% eBPF                           |
| **网络延迟**    | ⭐⭐⭐⭐⭐  | ⭐         | **纯 eBPF**   | 100% eBPF                           |
| **HTTP 状态码** | ⭐⭐⭐⭐    | ⭐⭐       | **eBPF 为主** | 90% eBPF, 10% SDK (自定义头)        |
| **日志事件**    | ⭐⭐⭐⭐    | ⭐⭐⭐⭐   | **混合**      | 90% eBPF (stdout), 10% SDK (结构化) |
| **业务指标**    | ⭐          | ⭐⭐⭐⭐⭐ | **纯 SDK**    | 100% SDK                            |
| **分布式追踪**  | ⭐⭐⭐      | ⭐⭐⭐⭐⭐ | **SDK 为主**  | 30% eBPF, 70% SDK                   |
| **性能剖析**    | ⭐⭐⭐⭐⭐  | ⭐⭐⭐     | **eBPF 为主** | 95% eBPF, 5% SDK (特定函数)         |
| **安全审计**    | ⭐⭐⭐⭐⭐  | ⭐⭐       | **纯 eBPF**   | 100% eBPF                           |
| **异步追踪**    | ⭐          | ⭐⭐⭐⭐⭐ | **纯 SDK**    | 100% SDK                            |
| **批处理关联**  | ⭐          | ⭐⭐⭐⭐⭐ | **纯 SDK**    | 100% SDK                            |

**核心策略**：

- **eBPF 负责**：所有**系统层面**、**性能敏感**、**安全相关**的观测
- **SDK 负责**：所有**业务层面**、**逻辑关联**、**异步语义**的观测
- **黄金比例**：**70% eBPF 自动采集 + 30% SDK 手动补充** = **100% 全栈可观测**

### 3.2 决策模型

**决策树模型**：

```text
需要观测什么？
├─ 系统资源/网络/安全 → 纯 eBPF
├─ 业务逻辑/事务 → 需 SDK
│  ├─ 异步场景？ → 是 → 必须 SDK
│  └─ 同步场景？ → 混合架构（eBPF + SDK）
└─ 性能剖析 → eBPF 为主，SDK 补充
```

### 3.3 行业最佳实践

根据 2024 年 CNCF 调查报告：

| 场景         | 推荐比例             | 行业采用率 |
| ------------ | -------------------- | ---------- |
| **纯 eBPF**  | 系统资源、网络、安全 | 85%        |
| **纯 SDK**   | 业务指标、异步追踪   | 90%        |
| **混合架构** | 分布式追踪、日志     | 75%        |

---

## 4 成熟度演进路线：从"混合"到"自治"

### 4.1 演进时间线

**2024 Q3：混合架构 1.0**:

- 比例：70% eBPF 广度 + 30% SDK 深度
- 标志：CO-RE 生产落地
- SDK 省却率：50% (仅保留业务埋点)

**2024 Q4：混合架构 2.0**:

- 比例：80% eBPF + 20% SDK
- 标志：Arrow 列式编码 GA
- 新增能力：eBPF 自动 W3C Trace Context 注入
- SDK 省却率：60% (SDK 专注纯业务)

**2025 Q1：混合架构 3.0**:

- 比例：85% eBPF + 15% SDK
- 标志：Python/Node.js 符号解析完善
- 新增能力：eBPF 自动关联 Kafka 消息
- SDK 省却率：70% (仅异步场景)

**2025 Q2：混合架构 4.0**:

- 比例：90% eBPF + 10% SDK
- 标志：内核态 ML 推理框架
- 新增能力：预测性埋点（AI 决定何时需 SDK 补充）
- SDK 省却率：80% (按需埋点)

**2025 Q4：自治架构**:

- 比例：95% eBPF + 5% SDK
- 标志：业务语义自动推断（研究阶段）
- 新增能力：NLP 解析日志 → 自动提取业务实体
- SDK 省却率：90% (仅极端场景)

**关键里程碑**：

- **2024 Q3**：CO-RE 成为事实标准，**BCC 彻底淘汰**
- **2025 Q1**：eBPF 实现**Kafka/RabbitMQ 协议自动解析**，异步追踪省却率从 0%→60%
- **2025 Q4**：**内核态 eBPF-ML 框架**诞生，实现预测性埋点，SDK 仅在 AI 不确定时
  介入

### 4.2 演进驱动力分析

**技术驱动力**：

- **内核能力扩展**：LSM、fentry、fexit 等新 Hook
- **协议解析能力**：Kafka、RabbitMQ 协议自动解析
- **AI 技术成熟**：内核态 ML 推理框架

**业务驱动力**：

- **成本压力**：减少 SDK 维护成本
- **效率需求**：提升开发效率
- **质量要求**：提升观测覆盖率

### 4.3 演进风险评估

**技术风险**：

- **符号解析失败**：动态语言支持不完善
- **性能影响**：eBPF 程序可能影响性能
- **兼容性问题**：内核版本依赖

**业务风险**：

- **迁移复杂度**：从传统架构迁移需要时间
- **技能缺口**：团队缺乏 eBPF 技能
- **投资回报**：投资回报不确定

---

## 5 技术选型与风险缓解

### 5.1 技术选型决策树

#### 5.1.1 决策流程

1. **需要观测什么？**

   - 系统资源、网络、安全 → **纯 eBPF**
   - 业务逻辑、事务、异步 → **需 SDK**

2. **内核版本>=4.14?**

   - 是 → 使用 CO-RE libbpf
   - 否 → 使用 BCC（过渡期）

3. **语言支持 OTel SDK?**

   - 是 → 使用 OTel SDK
   - 否 → 日志埋点+日志解析

4. **需要关联业务标签?**

   - 是 → eBPF + SDK 补充业务标签
   - 否 → 纯 eBPF，无需 SDK

5. **需要深度追踪?**
   - 是 → SDK 为主 + eBPF 自动补充系统 Span
   - 否 → SDK 仅 Metrics/Logs

#### 5.1.2 2024 年推荐配置

```yaml
# 生产环境务实配置
opentelemetry:
  # SDK部分（30%深度语义）
  sdk:
    enabled: true
    instrumentations:
      - name: spring-boot
        enabled: true # 自动注入Controller/Service埋点
      - name: kafka
        enabled: true # 必须，eBPF无法处理异步追踪
    manual_instrumentations:
      - business_events: true # 手动标记订单、支付等业务事件

  # eBPF部分（70%广度覆盖）
  ebpf:
    enabled: true
    programs:
      - name: system_metrics
        type: tracepoint
        scope: ["syscalls/sys_enter_read", "syscalls/sys_enter_write"]
      - name: network_tracing
        type: kprobe
        scope: ["tcp_connect", "tcp_sendmsg"]
        trace_context:
          inject_from_sdk: true # 从SDK Span提取traceparent注入到eBPF Span
      - name: security_audit
        type: lsm
        scope: ["file_open", "socket_connect"]

  # 融合策略
  fusion:
    span_merge: true
    ebpf_as_fallback: true # SDK未覆盖时自动使用eBPF
    deduplication: true # 去重SDK和eBPF重复数据
```

### 5.2 风险缓解策略

#### 5.2.1 风险 1：eBPF 程序导致内核不稳定

**缓解措施**：

- 使用**CO-RE + libbpf 1.0+**，社区验证的超 10 亿次加载
- **灰度**：DaemonSet 按节点池滚动升级，先测试环境 → 预发 → 生产（5%→50%→100%）
- **回滚**：`bpf_map_delete_elem()`卸载程序，秒级回滚

#### 5.2.2 风险 2：符号解析失败导致追踪断裂

**缓解措施**：

- 对**Go/Python/Node.js**服务，**必须保留 SDK**（70% eBPF + 30% SDK）
- **降级**：eBPF 栈回溯失败时，自动降级为纯 SDK 模式

#### 5.2.3 风险 3：人才储备不足

**缓解措施**：

- 采用**托管服务**（如 GKE Dataplane V2、AKS eBPF Monitor），降低自研门槛
- **培训**：聚焦 CO-RE 开发，避免 BCC 等过时技术

### 5.3 案例研究

#### 5.3.1 案例 1：大型互联网公司

**背景**：1000+ 微服务，日均 10 亿请求

**挑战**：

- SDK 埋点覆盖不足 40%
- 维护成本高
- 故障定位困难

**解决方案**：

- 混合架构（70% eBPF + 30% SDK）
- DeepFlow 混合组装

**效果**：

- 覆盖率提升至 **98%**
- 维护成本降低 **90%**
- MTTR 降至 **5 分钟**

#### 5.3.2 案例 2：金融科技公司

**背景**：高频交易系统，延迟敏感

**挑战**：

- SDK 埋点引入延迟
- 无法追踪内核层性能

**解决方案**：

- eBPF 零开销采集
- SDK 仅保留关键业务语义（10%）

**效果**：

- 追踪开销降低 **90%**
- 交易延迟优化 **30%**

---

## 6 结论与展望

### 6.1 核心结论

❌ **错误认知**：eBPF+OTLP 将**完全省却**SDK，实现 100%零代码观测 ✅ **正确认
知**：eBPF+OTLP**增强**了观测能力，**减少**60-70%无意义埋点，但**无法替
代**30-40%核心业务语义

### 6.2 理论意义

混合架构设计体现了以下理论意义：

1. **互补性理论的实践**：eBPF 和 SDK 在观测维度上互补，无法相互替代
2. **关注点分离原则的体现**：系统层与业务层分离，降低复杂度
3. **架构演进理论的验证**：从混合到自治的渐进式演进路径

### 6.3 未来展望

**短期（2024-2025）**：

- 混合架构标准化（70% eBPF + 30% SDK）
- 更多行业最佳实践
- 工具链完善

**中期（2025-2026）**：

- AI 驱动的智能埋点
- 业务语义自动推断
- 零配置混合架构

**长期（2026+）**：

- 完全自治的观测系统
- 业务语义自动提取
- 跨语言统一追踪

**价值再定义**：

**eBPF+OTLP 的真正价值**：

1. **消除"噪音埋点"**：系统指标、网络延迟、CPU 剖析等**机械性**工作 → **100%自动
   化**
2. **聚焦"价值埋点"**：业务事件、异步关联、复杂规则 → **开发者精力集中**
3. **提供"兜底观测"**：当 SDK 缺失或故障时，eBPF 作为**最后观测防线**

**未来终局展望（2026-2027）**：

**预测**：当以下技术成熟时，SDK 埋点可能进一步减少至 **5-10%**：

- **内核态 WASM**：在 eBPF 中运行业务逻辑，动态注入语义
- **AI 代码分析**：静态分析源码自动推断业务实体
- **标准化契约**：OpenAPI/Smithy 契约直接生成 eBPF 探针

**但终极边界**：只要存在**业务规则解释**，就需**人类意图编码**，SDK 就**无法完全
消除**。

**最终建议（2024-2025）**：

- **拥抱混合**：70% eBPF 自动化 + 30% SDK 精细化
- **投资 eBPF**：DaemonSet + CO-RE 作为基础设施基座
- **保留 SDK**：专注业务事件和异步追踪
- **持续评估**：每季度评估 eBPF 新能力，逐步迁移机械埋点

---

## 🔗 相关文档

- [代码省却](../01-code-savings/code-savings.md) - 程序设计功能需求的省却
- [架构组件省却](../02-architecture-savings/architecture-savings.md) - 架构组件
  服务需求的省却
- [分布式调用链](../08-distributed-tracing/distributed-tracing.md) - eBPF 与
  OTLP 的共生关系
- [综合分析](../09-comprehensive-analysis/comprehensive-analysis.md) - 省却的价
  值量化

---

**最后更新：2025-11-15 **维护者**：项目团队
