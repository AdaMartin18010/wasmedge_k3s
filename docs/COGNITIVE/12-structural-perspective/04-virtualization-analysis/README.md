# 12.4 虚拟化容器化沙盒化的结构分析

## 📑 目录

- [📑 目录](#-目录)
- [12.4.1 文档概述](#1241-文档概述)
- [12.4.2 结构主义三棱镜分析](#1242-结构主义三棱镜分析)
  - [核心思想](#核心思想)
  - [三件套的最小定义](#三件套的最小定义)
  - [结构主义三棱镜](#结构主义三棱镜)
- [12.4.3 复合技术分析](#1243-复合技术分析)
  - [复合结构示例](#复合结构示例)
- [12.4.4 选型原则](#1244-选型原则)
  - [结构主义选型格言](#结构主义选型格言)
  - [选型/迁移口诀（结构版）](#选型迁移口诀结构版)
- [12.4.5 参考](#1245-参考)
  - [相关文档](#相关文档)

---

## 12.4.1 文档概述

本目录包含用结构主义视角分析虚拟化、容器化、沙盒化的文档：

1. **[结构主义三棱镜分析](01-triple-structure-prism.md)** - 用三类结构重新审视三
   条技术路线
2. **[复合技术分析](02-composite-technologies.md)** -
   KVM+QEMU、gVisor、Firecracker、WASM 等复合技术
3. **[选型原则](03-selection-principles.md)** - 结构主义选型格言和原则

---

## 12.4.2 结构主义三棱镜分析

### 核心思想

把"虚拟化 / 容器化 / 沙盒化"再放进"三元结构"天平称一次，你会发现它们其实**共用同
一套机制**，只是**在三大结构上的取舍比例不同**—— 像极了"拓扑群" vs"李群"：材料一
样，骨架不同。

### 三件套的最小定义

| 概念                    | 一句话定义                                          | 核心目的                                     |
| ----------------------- | --------------------------------------------------- | -------------------------------------------- |
| 虚拟化 Virtualization   | 把**硬件指令集+资源**做成**可多路复用的抽象**       | 让多台"机器"互不感知地跑在同一物理机上       |
| 容器化 Containerization | 把**操作系统调用+命名空间**做成**可多路复用的抽象** | 让多组进程以为自己独占整个 Linux             |
| 沙盒化 Sandboxing       | 把**权限+可见性**做成**可受限的抽象**               | 让同一把用户态二进制跑在**最小可行上下文**里 |

### 结构主义三棱镜

| 结构维度                        | 虚拟化                                                                                                                                 | 容器化                                                                                                                                                                | 沙盒化                                                                                                                                         |
| ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| **计算结构**<br>(Computational) | • 指令集级**完全封闭**<br>• 客户机指令被**动态二进制翻译**或硬件捕获<br>• 状态=寄存器+内存+设备，**可快照**                            | • 系统调用级**半封闭**<br>• 进程继续发**原生指令**，只有**syscall 被重定向**<br>• 状态 ≈ cgroup+namespace+rootfs，**可镜像**                                          | • **用户态指令零修改**<br>• 仅把**危险 syscall 子集**过滤/仿真<br>• 状态 ≈ 过滤表+文件系统视图，**轻量**                                       |
| **控制结构**<br>(Control)       | • **强序保证**：VM-Exit/Entry 形成**全局同步点**<br>• 客户机内部再并发，**Host 可透明抢占**<br>• 迁移=**停机-拷贝-恢复**，序被**冻结** | • **弱序**：namespace 隔离**PID/IPC/Net** 名字空间，**但时钟一致**<br>• cgroup 仅做**统计与冻结**，不重塑序<br>• 镜像层**只读共享**，写时复制**序局部化**             | • **最小序干预**：<br> – seccomp-bpf：**系统调用偏序过滤**<br> – pledge/unveil：**能力降序**<br>• 通常**不迁移**，序无需全局冻结               |
| **信息结构**<br>(Information)   | • **完全信息伪装**：ACPI 表/PCI 拓扑/CPUID 皆可**伪造**<br>• 内存与磁盘**字节级隔离**<br>• 代价：**冗余内核+镜像**                     | • **部分信息伪装**：<br> – `/proc`、`/sys` 视图被**重新挂载**<br> – 但**内核版本相同**，**系统调用语义一致**<br>• 镜像分层=**信息拓扑的"近似"**：只读层+写层=**开集** | • **最小信息欺骗**：<br> – 仅**文件系统 chroot/namespace**<br> – 返回**ENOENT** 而不是**伪造内容**<br>• 错误码**保持原有语义**，**不扭曲拓扑** |

一句话总结： **虚拟化"重计算"、容器化"折中"、沙盒化"轻信息"**。

**详细文档**：[01-triple-structure-prism.md](01-triple-structure-prism.md)

---

## 12.4.3 复合技术分析

### 复合结构示例

| 杂交案例             | 计算                                | 控制                                  | 信息                                    | 一句话点评                 |
| -------------------- | ----------------------------------- | ------------------------------------- | --------------------------------------- | -------------------------- |
| **KVM+QEMU**         | 硬件虚拟化                          | 用户态事件循环                        | 可选 virtio-**fs** 缓存一致性           | 经典"**计算结构主导**"     |
| **gVisor**           | 用户态**Sentry** 重新实现 Linux ABI | 内部**独立调度器**⇒ 控制再分层        | 仅暴露**fake /proc**                    | **计算+控制**双高，信息轻  |
| **Firecracker**      | KVM 指令级                          | **微 VM** 极短退出路径                | **设备树极简**                          | 把虚拟化**往信息结构压薄** |
| **Docker + seccomp** | 容器级                              | **控制结构双层**：namespace + seccomp | **信息视图再裁剪**                      | 容器套沙盒，**结构叠加**   |
| **WASM 沙盒**        | **字节码验证**（计算结构轻量伪装）  | **Capabilities 表**（控制）           | **线性内存**+**导入函数白名单**（信息） | 三轴都**中度**，故可跨平台 |

**详细文档**：[02-composite-technologies.md](02-composite-technologies.md)

---

## 12.4.4 选型原则

### 结构主义选型格言

> **"你要多假的机器？"**
>
> - 想要**完全假的机器**→ 虚拟化（计算结构爆表）
> - 想要**差不多假的机器**→ 容器化（计算-控制折中）
> - 只想**别让程序坏事**→ 沙盒化（信息结构优先）

### 选型/迁移口诀（结构版）

> **"向下买计算，向上买控制，向边买信息"**

- 需要**指令级兼容**→**往下走**：KVM/TEE
- 需要**毫秒级热迁移**→**控制轴加码**：Firecracker 微 VM
- 需要**镜像秒级分发**→**信息轴优化**：Docker 分层+压缩
- 需要**最小攻击面**→**信息轴剪枝**：seccomp + unveil + 线性内存

**详细文档**：[03-selection-principles.md](03-selection-principles.md)

---

## 12.4.5 参考

### 相关文档

- **[三类结构分析](../02-three-structures/README.md)** - 计算结构、控制结构、信
  息结构的深入分析
- **[技术堆栈结构分析](../05-tech-stack-analysis/README.md)** - 8 层技术堆栈的结
  构重心分析
- **[源文档](../../../structure_view.md)** - 结构视角的完整论述

---

**更新时间**：2025-11-05 **版本**：v1.0
