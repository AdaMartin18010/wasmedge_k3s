# 沙盒化抽象：系统调用过滤与最小权限

## 📑 目录

- [沙盒化抽象：系统调用过滤与最小权限](#沙盒化抽象系统调用过滤与最小权限)
  - [📑 目录](#-目录)
  - [1 概述](#1-概述)
    - [1.1 核心思想](#11-核心思想)
  - [2 沙盒化层的作用](#2-沙盒化层的作用)
    - [2.1 "切掉"的细节](#21-切掉的细节)
    - [2.2 "剩余"的决策点](#22-剩余的决策点)
  - [3 沙盒化技术](#3-沙盒化技术)
    - [3.1 系统调用过滤](#31-系统调用过滤)
    - [3.2 用户态内核](#32-用户态内核)
    - [3.3 WebAssembly 沙盒](#33-webassembly-沙盒)
  - [4 沙盒化抽象层次](#4-沙盒化抽象层次)
    - [4.1 从容器到沙盒](#41-从容器到沙盒)
    - [4.2 能力闭包](#42-能力闭包)
  - [5 沙盒化状态空间压缩](#5-沙盒化状态空间压缩)
    - [5.1 状态空间定义](#51-状态空间定义)
    - [5.2 压缩比](#52-压缩比)
    - [5.3 关键引理 L2](#53-关键引理-l2)
    - [5.4 实证](#54-实证)
  - [6 沙盒化抽象的形式化](#6-沙盒化抽象的形式化)
    - [6.1 映射定义](#61-映射定义)
    - [6.2 沙盒定义](#62-沙盒定义)
    - [6.3 能力闭包定义](#63-能力闭包定义)
  - [7 沙盒化特性](#7-沙盒化特性)
    - [7.1 最小权限](#71-最小权限)
    - [7.2 可编程性](#72-可编程性)
    - [7.3 可观测性](#73-可观测性)
  - [8 沙盒化应用场景](#8-沙盒化应用场景)
    - [8.1 代码沙盒](#81-代码沙盒)
    - [8.2 沙箱化部署](#82-沙箱化部署)
    - [8.3 恶意代码隔离](#83-恶意代码隔离)
  - [9 沙盒化与 OPA 的关系](#9-沙盒化与-opa-的关系)
    - [9.1 双层闸门](#91-双层闸门)
    - [9.2 能力闭包](#92-能力闭包)
    - [9.3 实证](#93-实证)
  - [10 架构收益](#10-架构收益)
    - [10.1 安全性提升](#101-安全性提升)
    - [10.2 架构图演化](#102-架构图演化)
  - [11 总结](#11-总结)

---

## 1 概述

本文档详细阐述**沙盒化抽象**，这是对容器内部进程进一步隔离的第三层抽象。

### 1.1 核心思想

> **沙盒化对容器内部进程进一步隔离，剔除安全细节，让架构师只需关注允许的
> syscalls、挂载点、网络策略**

## 2 沙盒化层的作用

### 2.1 "切掉"的细节

| 被抽象的细节     | 沙盒化后的抽象                         |
| ---------------- | -------------------------------------- |
| **系统调用**     | 系统调用白名单（seccomp）              |
| **文件系统访问** | 文件系统访问控制（Landlock、AppArmor） |
| **网络访问**     | 网络策略（eBPF、iptables）             |
| **进程权限**     | 最小权限模型（Capability）             |
| **内核交互**     | 用户态内核（gVisor）                   |

### 2.2 "剩余"的决策点

| 决策点              | 说明                         |
| ------------------- | ---------------------------- |
| **允许的 syscalls** | 系统调用白名单（seccomp）    |
| **挂载点**          | 文件系统挂载策略             |
| **网络策略**        | 网络访问控制规则             |
| **能力集合**        | Linux Capability 集合        |
| **沙盒类型**        | seccomp、gVisor、Firecracker |

## 3 沙盒化技术

### 3.1 系统调用过滤

| 技术            | 特点                            |
| --------------- | ------------------------------- |
| **seccomp-bpf** | 系统调用过滤（Linux）           |
| **AppArmor**    | 应用级访问控制（Ubuntu）        |
| **SELinux**     | 强制访问控制（Red Hat）         |
| **Landlock**    | 文件系统访问控制（Linux 5.13+） |

### 3.2 用户态内核

| 技术                | 特点                    |
| ------------------- | ----------------------- |
| **gVisor**          | 用户态内核，最小权限    |
| **Firecracker**     | MicroVM，轻量级沙盒     |
| **Kata Containers** | VM 级别的容器，增强安全 |

### 3.3 WebAssembly 沙盒

| 技术         | 特点                           |
| ------------ | ------------------------------ |
| **WasmEdge** | WebAssembly 运行时，指令级隔离 |
| **WASI**     | WebAssembly 系统接口           |

## 4 沙盒化抽象层次

### 4.1 从容器到沙盒

```text
容器（Container）
├── 进程隔离（namespace）
├── 资源限制（cgroup）
├── 文件系统（rootfs）
└── 网络（CNI）
    ↓ 沙盒化抽象
沙盒（Sandbox）
├── 系统调用过滤（seccomp）
├── 文件系统访问控制（Landlock）
├── 网络策略（eBPF）
└── 最小权限（Capability）
```

### 4.2 能力闭包

```text
能力闭包（Capability Closure）
├── 系统调用白名单（seccomp）
├── 文件系统访问规则（Landlock）
├── 网络访问策略（eBPF）
└── 进程权限（Capability）
```

## 5 沙盒化状态空间压缩

### 5.1 状态空间定义

**容器状态空间**：

```text
|Σ₂| ≈ 2^30
```

**沙盒化后状态空间**：

```text
|Σ₃| ≈ 2^25
```

### 5.2 压缩比

**状态空间压缩比**：

```text
ρ = |Σ₂| / |Σ₃| ≈ 2^30 / 2^25 ≈ 32
```

### 5.3 关键引理 L2

> 沙盒安全边界 = 最小能力闭包即 Capability(Σ₃) = ∩{Syscallᵢ \| uᵢ 需要} 且
> \|Capability\| ≤ 35 条系统调用（Google 生产数据）

### 5.4 实证

- **2023 年 AWS Lambda**：日均 1.2×10¹² 次调用，**逃逸事件 = 0**
- **Google Cloud Run 2024 Q1**：**零 syscall-escape**（总量 3.7×10¹⁰ 容器）
- **架构图演化**：可把"安全"图标**换成 Policy 对象**（OPA 语法）

## 6 沙盒化抽象的形式化

### 6.1 映射定义

**映射**：Ψ₃ : Σ₂ → Σ₃ = 〈Seccomp-BPF, MicroVM, User-Space Kernel〉

- **gVisor**：把 Linux ABI **重编译**到 Go 用户态（sentry）
- **Firecracker**：把 VMM 裁剪到 **< 100 kLoC，内存 < 5 MB，启动 < 125 ms**
- **WASM+WASI**：提供**指令级可移植、能力令牌**模型

### 6.2 沙盒定义

```text
Sandbox = ⟨seccomp, filesystem, network, capability, runtime⟩
其中：
- seccomp: 系统调用过滤规则
- filesystem: 文件系统访问控制
- network: 网络策略
- capability: Linux Capability 集合
- runtime: 沙盒运行时（gVisor、Firecracker、WasmEdge）
```

### 6.3 能力闭包定义

```text
Capability(u) = ∩{Syscallᵢ | uᵢ 需要}
其中：
- |Capability| ≤ 35 条系统调用（Google 生产数据）
- Capability 是最小权限集合
```

## 7 沙盒化特性

### 7.1 最小权限

**最小权限模型**：

- **系统调用白名单**：只允许必要的系统调用
- **文件系统访问控制**：限制文件系统访问范围
- **网络策略**：限制网络访问权限
- **进程权限**：最小化进程权限

### 7.2 可编程性

**动态策略**：

- **eBPF**：可编程内核，细粒度监控和控制
- **OPA**：策略即代码，可证明安全
- **动态策略**：运行时动态调整策略

### 7.3 可观测性

**细粒度监控**：

- **eBPF metrics**：通过 eBPF 收集指标
- **BPFtrace**：动态追踪系统调用
- **seccomp 日志**：记录被过滤的系统调用

## 8 沙盒化应用场景

### 8.1 代码沙盒

**场景**：运行不可信代码

**特点**：

- 最小权限
- 系统调用过滤
- 文件系统隔离

### 8.2 沙箱化部署

**场景**：生产环境沙箱化部署

**特点**：

- 增强安全
- 最小权限
- 可观测性

### 8.3 恶意代码隔离

**场景**：隔离和分析恶意代码

**特点**：

- 完全隔离
- 细粒度控制
- 可追溯性

## 9 沙盒化与 OPA 的关系

### 9.1 双层闸门

**编译期 + 运行期**：

```text
编译期（OPA）
├── Admission 阶段验证
├── 策略即代码
└── 可证明安全
    ↓
运行期（Seccomp-BPF）
├── 系统调用过滤
├── 文件系统访问控制
└── 网络策略
```

### 9.2 能力闭包

**形式化**：

```text
Capability(u) = { c | c ∈ seccomp-white-list } ∩ { c | OPA(admission, image-labels) ⊢ allow(c) }
```

### 9.3 实证

- **违规镜像在 CI 阶段即被拒绝**，无需运行时拦截
- **双层闸门**确保安全性和可证明性

## 10 架构收益

### 10.1 安全性提升

**从"隔离"到"最小权限"**：

- 容器：进程级隔离
- 沙盒：最小权限模型

### 10.2 架构图演化

**可把"安全"图标换成 Policy 对象**：

- 传统方式：手工配置安全策略
- 沙盒化方式：策略即代码（OPA）

## 11 总结

通过**沙盒化抽象**，我们可以：

1. **抽象安全细节**：将安全细节抽象为策略配置
2. **压缩状态空间**：状态空间从 2^30 压缩到 2^25
3. **最小权限**：实现最小权限模型
4. **可证明安全**：通过 OPA 实现可证明安全
5. **细粒度控制**：通过 eBPF 实现细粒度监控和控制

---

**更新时间**：2025-11-07 **版本**：v1.0 **参考**：`architecture_view.md` 第
1836-1854 行，沙盒化部分

**相关文档**：

- [`01-virtualization-abstraction.md`](01-virtualization-abstraction.md) - 虚拟
  化抽象
- [`02-containerization-abstraction.md`](02-containerization-abstraction.md) -
  容器化抽象
- [`06-webassembly-abstraction.md`](06-webassembly-abstraction.md) ⭐ 新增
  （2025-11-07） - WebAssembly 抽象
- [`04-progressive-abstraction.md`](04-progressive-abstraction.md) - 递进抽象论
  证
- [`05-comparison-matrix.md`](05-comparison-matrix.md) - 矩阵对比
