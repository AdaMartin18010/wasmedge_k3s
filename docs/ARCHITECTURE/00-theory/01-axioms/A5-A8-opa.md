# A5-A8：OPA 策略治理公理

## 📑 目录

- [📑 目录](#-目录)
- [1. 概述](#1-概述)
  - [1.1 核心思想](#11-核心思想)
- [2. OPA 公理体系概览](#2-opa-公理体系概览)
- [3. A5：能力闭包公理](#3-a5能力闭包公理)
  - [3.1 公理描述](#31-公理描述)
  - [3.2 形式化定义](#32-形式化定义)
  - [3.3 OPA 对应实体](#33-opa-对应实体)
  - [3.4 公理说明](#34-公理说明)
  - [3.5 验证方法](#35-验证方法)
- [4. A6：最小权限公理](#4-a6最小权限公理)
  - [4.1 公理描述](#41-公理描述)
  - [4.2 形式化定义](#42-形式化定义)
  - [4.3 OPA 对应实体](#43-opa-对应实体)
  - [4.4 公理说明](#44-公理说明)
  - [4.5 验证方法](#45-验证方法)
- [5. A7：可证明性公理](#5-a7可证明性公理)
  - [5.1 公理描述](#51-公理描述)
  - [5.2 形式化定义](#52-形式化定义)
  - [5.3 OPA 对应实体](#53-opa-对应实体)
  - [5.4 公理说明](#54-公理说明)
  - [5.5 验证方法](#55-验证方法)
- [6. A8：版本一致性公理](#6-a8版本一致性公理)
  - [6.1 公理描述](#61-公理描述)
  - [6.2 形式化定义](#62-形式化定义)
  - [6.3 OPA 对应实体](#63-opa-对应实体)
  - [6.4 公理说明](#64-公理说明)
  - [6.5 验证方法](#65-验证方法)
- [7. 公理之间的关系](#7-公理之间的关系)
  - [7.1 公理依赖关系](#71-公理依赖关系)
  - [7.2 与基础公理的关系](#72-与基础公理的关系)
- [8. 验证方法](#8-验证方法)
  - [8.1 理论验证](#81-理论验证)
  - [8.2 实证验证](#82-实证验证)
- [9. 相关文档](#9-相关文档)
  - [9.1 归纳证明文档](#91-归纳证明文档)
  - [9.2 引理和定理文档](#92-引理和定理文档)
  - [9.3 公理层文档](#93-公理层文档)
  - [9.4 源文档](#94-源文档)

---

## 1. 概述

**A5-A8 OPA 策略治理公理**定义了策略治理的基本性质，是 OPA（Open Policy Agent）
形式化论证的基础。

### 1.1 核心思想

> **OPA 把"安全"从不可量化的运维玄学，变成了一段可单元测试、可形式化验证、可与业
> 务代码同版本回滚的 DSL**

---

## 2. OPA 公理体系概览

| 公理          | 形式化描述                         | OPA 对应实体                                    |
| ------------- | ---------------------------------- | ----------------------------------------------- |
| A5 能力闭包   | ∀u∈U, Capability(u) ⊆ ∩{syscallᵢ}  | `deny[msg] { capability[_] != required }`       |
| A6 最小权限   | ∀ edge e∈G, Role(e) ⊆ Need-to-know | `allow = true { input.user == resource.owner }` |
| A7 可证明性   | 策略决策 ≡ 布尔可满足性（SAT）     | Rego → JSON → AST → SAT 求解                    |
| A8 版本一致性 | Policy Δ ≃ Code Δ                  | Git SHA 相同即可重现决策                        |

---

## 3. A5：能力闭包公理

### 3.1 公理描述

**公理 A5**：∀u∈U, Capability(u) ⊆ ∩{syscallᵢ | uᵢ 需要}

即对于任意计算单元 u，其能力闭包 Capability(u) 是所有必需系统调用的交集，且是最
小的。

### 3.2 形式化定义

**形式化**：

```text
∀u∈U, Capability(u) ⊆ ∩{syscallᵢ | uᵢ 需要} 且
|Capability| ≤ 35 条系统调用（Google 生产数据）
```

其中：

- **U**：计算单元集合（VM、Container、Sandbox）
- **Capability(u)**：单元 u 的能力闭包
- **syscallᵢ**：单元 uᵢ 需要的系统调用集合
- **∩**：交集运算

### 3.3 OPA 对应实体

**Rego 示例**：

```text
deny[msg] {
    capability[_] != required
    msg := "Capability not in required set"
}
```

### 3.4 公理说明

**能力闭包**意味着：

1. **最小性**：能力闭包是最小的，只包含必需的系统调用
2. **封闭性**：能力闭包是封闭的，不包含多余的系统调用
3. **安全性**：限制系统调用数量可以降低安全风险

### 3.5 验证方法

**理论验证**：证明能力闭包是最小的

**实证验证**：

- Google 生产数据：大多数应用只需要 ≤ 35 条系统调用
- AWS Lambda 2023：日均 1.2×10¹² 次调用，逃逸事件 = 0

---

## 4. A6：最小权限公理

### 4.1 公理描述

**公理 A6**：∀ edge e∈G, Role(e) ⊆ Need-to-know

即对于任意边 e（服务间通信），其角色 Role(e) 只包含需要知道的信息，满足最小权限
原则。

### 4.2 形式化定义

**形式化**：

```text
∀ edge e∈G, Role(e) ⊆ Need-to-know(e)
```

其中：

- **G**：组合图谱（服务间关系）
- **e**：边（服务间通信）
- **Role(e)**：边 e 的角色（权限集合）
- **Need-to-know(e)**：边 e 需要知道的信息集合

### 4.3 OPA 对应实体

**Rego 示例**：

```text
allow = true {
    input.user == resource.owner
    input.action == "read"
}
```

### 4.4 公理说明

**最小权限**意味着：

1. **Need-to-know**：只授予访问所需信息的最小权限
2. **角色限制**：角色权限不能超过需要知道的范围
3. **权限最小化**：权限集合是最小的

### 4.5 验证方法

**理论验证**：证明角色权限满足最小权限原则

**实证验证**：

- Service Mesh + OPA：实现了细粒度的权限控制
- 权限策略可以自动验证和审计

---

## 5. A7：可证明性公理

### 5.1 公理描述

**公理 A7**：策略决策 ≡ 布尔可满足性（SAT）

即策略决策过程等价于布尔可满足性问题，可以通过 SAT 求解器自动验证。

### 5.2 形式化定义

**形式化**：

```text
策略决策 ≡ 布尔可满足性（SAT）
即 ∃SAT 求解器 : OPA(i) = SAT(Rego(i))
```

其中：

- **OPA(i)**：OPA 对输入 i 的决策
- **Rego(i)**：输入 i 对应的 Rego 策略
- **SAT**：布尔可满足性求解器

### 5.3 OPA 对应实体

**转换过程**：

```text
Rego → JSON → AST → SAT 求解
```

### 5.4 公理说明

**可证明性**意味着：

1. **形式化**：策略决策可以形式化为 SAT 问题
2. **可验证**：可以使用 SAT 求解器自动验证策略
3. **确定性**：策略决策是确定性的，可重现

### 5.5 验证方法

**理论验证**：证明 Rego 策略可以转换为 SAT 问题

**实证验证**：

- OPA 决策在有限步内唯一且可重现（引理 L3）
- 2023 年 CNCF Survey：OPA 平均评估延迟 1.2 ms，P99 6 ms

---

## 6. A8：版本一致性公理

### 6.1 公理描述

**公理 A8**：Policy Δ ≃ Code Δ

即策略变更 Policy Δ 与代码变更 Code Δ 等价，策略与代码同版本、同回滚。

### 6.2 形式化定义

**形式化**：

```text
Policy Δ ≃ Code Δ
即 ∀Git SHA, Policy(Git SHA) = Code(Git SHA)
```

其中：

- **Policy Δ**：策略变更
- **Code Δ**：代码变更
- **Git SHA**：Git 提交哈希
- **≃**：等价关系

### 6.3 OPA 对应实体

**版本管理**：

```text
Git SHA 相同即可重现决策
```

### 6.4 公理说明

**版本一致性**意味着：

1. **同版本**：策略与代码使用相同的版本标识（Git SHA）
2. **同回滚**：策略与代码可以同步回滚
3. **可追溯**：策略变更可以追溯到代码变更

### 6.5 验证方法

**理论验证**：证明策略与代码版本一致

**实证验证**：

- 同一 Bundle（Git SHA=abc123）在不同集群决策一致性 = 100%（n=5×10⁷）
- 策略与代码可以同步版本管理和回滚

---

## 7. 公理之间的关系

### 7.1 公理依赖关系

```text
A5 (能力闭包) → A6 (最小权限)
A7 (可证明性) → A8 (版本一致性)
A5-A8 → 统一中层模型 ℳ 的可证明安全性
```

### 7.2 与基础公理的关系

- **A1-A4**：基础公理（可计算性、资源封闭、网络异步、分层抽象）
- **A5-A8**：OPA 公理（能力闭包、最小权限、可证明性、版本一致性）
- **关系**：A5-A8 在 A1-A4 基础上增加了策略治理的严格性

---

## 8. 验证方法

### 8.1 理论验证

**方法**：证明 OPA 公理的形式化正确性

**步骤**：

1. **定义策略模型**：定义策略的形式化模型
2. **定义决策过程**：定义策略决策的形式化过程
3. **证明公理**：证明 A5-A8 在形式化模型中的正确性

### 8.2 实证验证

**方法**：使用实际系统验证 OPA 公理

**案例**：

- **gVisor + OPA**：能力闭包下沉到沙盒（A5）
- **Service Mesh + OPA**：服务间权限组合化（A6）
- **OPA 决策确定性**：决策唯一且可重现（A7）
- **GitOps + OPA**：策略与代码同版本（A8）

---

## 9. 相关文档

### 9.1 归纳证明文档

- [`../02-induction-proof/`](../02-induction-proof/) - 归纳证明文档集

### 9.2 引理和定理文档

- [`../05-lemmas-theorems/L2-capability-closure.md`](../05-lemmas-theorems/L2-capability-closure.md) -
  L2：能力闭包引理
- [`../05-lemmas-theorems/L3-opa-determinism.md`](../05-lemmas-theorems/L3-opa-determinism.md) -
  L3：OPA 确定性引理

### 9.3 公理层文档

- [`README.md`](README.md) - 公理层总览
- [`A1-von-neumann.md`](A1-von-neumann.md) - A1：冯·诺依曼等价
- [`A2-os-resource.md`](A2-os-resource.md) - A2：OS 资源封闭
- [`A3-network-async.md`](A3-network-async.md) - A3：网络异步交付
- [`A4-layer-abstraction.md`](A4-layer-abstraction.md) - A4：分层可抽象

### 9.4 源文档

- [`../../architecture_view.md`](../../architecture_view.md) - 架构视角的核心论
  述

---

**更新时间**：2025-11-04 **版本**：v1.0 **参考**：`architecture_view.md` OPA 公
理部分
